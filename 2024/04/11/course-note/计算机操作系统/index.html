<!DOCTYPE html>
<html lang="zh-cn,en,default">
<head>
  <meta charset="UTF-8">




<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

  <meta name="author" content="崔若晨 Ruochen Cui">


  <meta name="subtitle" content="崔若晨">


  <meta name="description" content="电子科技大学四年级本科生

A fourth year undergraduate student at UESTC
">


  <meta name="keywords" content="Ruochen Cui,崔若晨,Artificial Intelligence">


<title>2023-2024秋季学期计算机操作系统期末预习笔记 | Ruochen Cui</title>



<link rel="icon" href="/web_ico.ico">


<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"
/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">


<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/search.css">



<script src="/lib/jquery.min.js"></script>


<script src="/lib/iconify-icon.min.js"></script>


<script src="https://cdn.tailwindcss.com?plugins=typography"></script>
<script>
  tailwind.config = {
    darkMode: "class",
  };
</script>

<script>
  (function () {
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const setting = localStorage.getItem("hexo-color-scheme") || "auto";
    if (setting === "dark" || (prefersDark && setting !== "light"))
      document.documentElement.classList.toggle("dark", true);
    let isDark = document.documentElement.classList.contains("dark");
  })();

  $(document).ready(function () {
    // init icon
    const prefersDark =
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isDark = document.documentElement.classList.contains("dark");
    $("#theme-icon").attr("icon", isDark ? "ic:round-dark-mode" : "ic:round-light-mode");

    function toggleGiscusTheme() {
      const isDark = document.documentElement.classList.contains("dark");
      const giscusFrame = document.querySelector("iframe.giscus-frame");
      if (giscusFrame) {
        giscusFrame.contentWindow.postMessage(
          {
            giscus: {
              setConfig: {
                theme: isDark ? "dark" : "light",
              },
            },
          },
          "https://giscus.app"
        );
      }
    }


    // toggle dark mode
    function toggleDark() {
      let isDark = document.documentElement.classList.contains("dark");
      const setting = localStorage.getItem("hexo-color-scheme") || "auto";
      isDark = !isDark;
      document.documentElement.classList.toggle("dark", isDark);
      $("#theme-icon").attr("icon", isDark ? "ic:round-dark-mode" : "ic:round-light-mode");
      if (prefersDark === isDark) {
        localStorage.setItem("hexo-color-scheme", "auto");
      } else {
        localStorage.setItem("hexo-color-scheme", isDark ? "dark" : "light");
      }
      toggleGiscusTheme();
    }
    $("#toggle-dark").click(toggleDark);

    // listen dark mode change
    window
      .matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", (e) => {
        const setting = localStorage.getItem("hexo-color-scheme") || "auto";
        if (setting === "auto") {
          document.documentElement.classList.toggle("dark", e.matches);
          $("#theme-icon").attr(
            "icon",
            e.matches ? "ic:round-dark-mode" : "ic:round-light-mode"
          );
          toggleGiscusTheme();
        }
      });
  });
</script>




<meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
<body 
  class="
    bg-[var(--c-0)]
    text-[var(--c-80)]
  ">
  <!-- The navigation bar -->
<header class="
    flex flex-row items-center
    w-full
    pr-4
    z-10
    border-b-[1px]
    border-b-[var(--c-border)]
    dark:bg-[var(--c-0)]
    dark:border-b-[var(--c-0)]
    gap-2
    h-[var(--h-header)]
    text-[var(--c-80)]
">
  <!-- Left part -->
  <div class="overflow-hidden h-full flex flex-row items-center">
    <!-- Site Title on the top left -->
    <a href="/" class="
            whitespace-nowrap
            text-2xl
            text-[var(--c-theme)]
            hover:text-[var(--c-theme)]
            pl-4
            font-black
            bg-gradient-to-r from-cyan-500
            to-blue-500 bg-clip-text text-transparent
          ">
      Ruochen Cui
    </a>
  </div>
  <!-- Div for pushing items to both sides -->
  <div class="flex-1"></div>
  <!-- Right part -->
  <div class="flex flex-row items-center z-20 h-full">
    <!-- Page links -->
    <div class="hidden sm:flex flex-row h-full">
      
      
      
      
      
      
      <a href="/./archives" class="
                        flex flex-row items-center
                        gap-1
                        hover:underline
                        hover:bg-[var(--c-20)]
                        hover:text-[var(--c-theme)]
                        transition-all
                        px-2
                        py-1
                        my-1
                        rounded-lg
                        group
                    ">
        
        <iconify-icon class="group-hover:scale-125 transition-transform" icon="mingcute:inbox-fill" width="22">
        </iconify-icon>
        
        
        <p>Posts</p>
        
      </a>
      
      
      
      
      
      
      <a href="/./publications" class="
                        flex flex-row items-center
                        gap-1
                        hover:underline
                        hover:bg-[var(--c-20)]
                        hover:text-[var(--c-theme)]
                        transition-all
                        px-2
                        py-1
                        my-1
                        rounded-lg
                        group
                    ">
        
        <iconify-icon class="group-hover:scale-125 transition-transform" icon="mingcute:science-fill" width="22">
        </iconify-icon>
        
        
        <p>Publications</p>
        
      </a>
      
      
      
      
      
      
      <a href="/./about" class="
                        flex flex-row items-center
                        gap-1
                        hover:underline
                        hover:bg-[var(--c-20)]
                        hover:text-[var(--c-theme)]
                        transition-all
                        px-2
                        py-1
                        my-1
                        rounded-lg
                        group
                    ">
        
        <iconify-icon class="group-hover:scale-125 transition-transform" icon="mingcute:user-info-fill" width="22">
        </iconify-icon>
        
        
        <p>About</p>
        
      </a>
      
      
      
      
      
      
      <a href="/./categories" class="
                        flex flex-row items-center
                        gap-1
                        hover:underline
                        hover:bg-[var(--c-20)]
                        hover:text-[var(--c-theme)]
                        transition-all
                        px-2
                        py-1
                        my-1
                        rounded-lg
                        group
                    ">
        
        <iconify-icon class="group-hover:scale-125 transition-transform" icon="mingcute:classify-2-fill" width="22">
        </iconify-icon>
        
        
        <p>Categories</p>
        
      </a>
      
      
      
      
      
      
      <a href="/./tags" class="
                        flex flex-row items-center
                        gap-1
                        hover:underline
                        hover:bg-[var(--c-20)]
                        hover:text-[var(--c-theme)]
                        transition-all
                        px-2
                        py-1
                        my-1
                        rounded-lg
                        group
                    ">
        
        <iconify-icon class="group-hover:scale-125 transition-transform" icon="mingcute:tag-fill" width="22">
        </iconify-icon>
        
        
        <p>Tags</p>
        
      </a>
      
      
      
      
      
      
      <a href="/./index" class="
                        flex flex-row items-center
                        gap-1
                        hover:underline
                        hover:bg-[var(--c-20)]
                        hover:text-[var(--c-theme)]
                        transition-all
                        px-2
                        py-1
                        my-1
                        rounded-lg
                        group
                    ">
        
        <iconify-icon class="group-hover:scale-125 transition-transform" icon="mingcute:home-2-fill" width="22">
        </iconify-icon>
        
        
      </a>
      
    </div>
    <!-- Icons on the right -->
    <div class="flex flex-row items-center">

      <!-- TODO: Add search icon here -->

      <!-- Dark/light toggle icon -->
      <a class="flex group p-1" title="toggle theme" id="toggle-dark">
        <iconify-icon class="transition-transform
                    group-hover:rotate-[45deg]
                    group-hover:scale-125
                    group-hover:text-[var(--c-theme)]" width="24" id="theme-icon">
        </iconify-icon>
      </a>
      <!-- Icon for dropout menu on small screens -->
      <div class="flex p-1 mx-1 sm:hidden">
        <a class="w-5 h-5" aria-hidden="true" id="open-menu">
          <iconify-icon width="24" icon="mingcute:menu-fill" class="transition-transform hover:scale-125 hover:rotate-[5deg]">
          </iconify-icon>
        </a>
        <a class="w-5 h-5 hidden" aria-hidden="true" id="close-menu">
          <iconify-icon width="24" icon="mingcute:close-circle-fill" class="transition-transform hover:scale-125 hover:rotate-[80deg]">
          </iconify-icon>
        </a>
      </div>
    </div>
  </div>
</header>

<!-- Dropdown menu on small screens -->
<div id="menu-panel" class="
        h-0
        overflow-hidden
        sm:hidden
        w-full
        z-10
        rounded
    ">
  <div id="menu-content" class="
        flex
        flex-row
        justify-center
        items-center
        font-bold
        text-xl
        border-b-[1px]
        relative
        z-20
        border-[var(--c-sep)]
        px-2
        py-2
        -translate-y-full
        transition-transform
        duration-200
        ">
    
    
    
    <a href="/./archives" class="
                flex flex-row items-center
                gap-2
                h-12
                hover:underline
                hover:bg-[var(--c-20)]
                px-3
                py-1
                rounded-lg
            ">
      <iconify-icon icon="mingcute:inbox-fill" width="22">
      </iconify-icon>
      <p>
        posts
      </p>
    </a>
    
    
    
    
    <a href="/./publications" class="
                flex flex-row items-center
                gap-2
                h-12
                hover:underline
                hover:bg-[var(--c-20)]
                px-3
                py-1
                rounded-lg
            ">
      <iconify-icon icon="mingcute:science-fill" width="22">
      </iconify-icon>
      <p>
        publications
      </p>
    </a>
    
    
    
    
    <a href="/./about" class="
                flex flex-row items-center
                gap-2
                h-12
                hover:underline
                hover:bg-[var(--c-20)]
                px-3
                py-1
                rounded-lg
            ">
      <iconify-icon icon="mingcute:user-info-fill" width="22">
      </iconify-icon>
      <p>
        about
      </p>
    </a>
    
    
    
    
    <a href="/./categories" class="
                flex flex-row items-center
                gap-2
                h-12
                hover:underline
                hover:bg-[var(--c-20)]
                px-3
                py-1
                rounded-lg
            ">
      <iconify-icon icon="mingcute:classify-2-fill" width="22">
      </iconify-icon>
      <p>
        categories
      </p>
    </a>
    
    
    
    
    <a href="/./tags" class="
                flex flex-row items-center
                gap-2
                h-12
                hover:underline
                hover:bg-[var(--c-20)]
                px-3
                py-1
                rounded-lg
            ">
      <iconify-icon icon="mingcute:tag-fill" width="22">
      </iconify-icon>
      <p>
        tags
      </p>
    </a>
    
    
    
    
    <a href="/./index" class="
                flex flex-row items-center
                gap-2
                h-12
                hover:underline
                hover:bg-[var(--c-20)]
                px-3
                py-1
                rounded-lg
            ">
      <iconify-icon icon="mingcute:home-2-fill" width="22">
      </iconify-icon>
      <p>
        home
      </p>
    </a>
    
    
  </div>
</div>
  <main>
    <!-- css -->

<link rel="stylesheet" href="/lib/fancybox/fancybox.min.css">

  
<link rel="stylesheet" href="/lib/tocbot/tocbot.min.css">

    <!-- toc -->
    
  <!-- tocbot -->
<nav class="post-toc toc text-sm w-40 relative top-32 right-4 opacity-70 hidden lg:block" style="position: fixed !important;"></nav>


<section class="px-6 max-w-prose mx-auto md:px-0">
  <!-- Post header before content -->
  <header class="py-4">
    <div class="flex flex-col gap-2 pt-4 md:pt-6">
      <!-- Title -->
      <div id="article-title" class="leading-snug">
        <p class="text-3xl font-bold text-[var(--c-100)] mb-4">2023-2024秋季学期计算机操作系统期末预习笔记</p>
      </div>
      <!-- Meta data -->
      <div>
        <section class="
          flex flex-col gap-x-2 gap-y-1 text-sm text-[var(--c-100)]">
          <div class="flex flex-wrap items-center gap-x-2 gap-y-1">
            <!-- Dates -->
            <div class="flex items-center gap-1">
              <iconify-icon width="18" icon="mingcute:add-circle-fill" ></iconify-icon>
              Created: <time class="w-max">2024-04-11</time>
            </div>
            <div class="flex items-center gap-1">
              <iconify-icon width="18" icon="mingcute:refresh-3-fill" ></iconify-icon>
              Edited: <time class="w-max">2024-10-14</time>
            </div>
          </div>
          <div class="flex flex-wrap items-center gap-x-3 gap-y-3">
            <!-- Author -->
            
              <span class="flex items-center gap-1 group">
                <iconify-icon width="18" icon="mingcute:user-edit-fill" ></iconify-icon>
                <p>myself</p>
              </span>
            

            <!-- Word count -->
            <span class="flex items-center gap-1">
              <iconify-icon width="18" icon="mingcute:book-2-fill" ></iconify-icon>
              <span>29.5k words, 100 min</span>
            </span>
            <!-- Categories -->
            
              <!-- <span class="text-gray-400">·</span> -->
              <span class="flex flex-row items-center gap-1 group hover:underline">
                <iconify-icon class="transition-all group-hover:scale-125 mr-0"
                  width="18"
                  icon="mingcute:classify-2-fill">
                </iconify-icon>
                <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </span>
            
          </div>
        </section>
      </div>
      <!-- tags -->
      <div>
        
<div class="flex flex-wrap gap-1">
  
    
      <a href="/tags/course-note/" 
        class="
          tag
          text-sm
          rounded-full
          px-[5px]
          border-[1px]
          border-[var(--c-theme)]
          text-[var(--c-theme)]
          bg-[var(--c-0)]
          dark:bg-[var(--c-0)]
          dark:drop-shadow-none
          hover:bg-[var(--c-theme)]
          hover:text-[var(--c-0)]
          dark:hover:text-[var(--c-theme-2)]
        ">
        course-note
      </a>
    
      <a href="/tags/cs/" 
        class="
          tag
          text-sm
          rounded-full
          px-[5px]
          border-[1px]
          border-[var(--c-theme)]
          text-[var(--c-theme)]
          bg-[var(--c-0)]
          dark:bg-[var(--c-0)]
          dark:drop-shadow-none
          hover:bg-[var(--c-theme)]
          hover:text-[var(--c-0)]
          dark:hover:text-[var(--c-theme-2)]
        ">
        cs
      </a>
    
  
</div>
      </div>
    </div>
  </header>
  <!-- content -->
  <article class="post-content prose m-auto dark:prose-invert">
    <p>[TOC]</p>
<p><a target="_blank" rel="noopener" href="https://uestc.feishu.cn/wiki/BoR4wMz1fi9MLqkbFhuczhv1nLc?from=from_copylink">飞书文档</a></p>
<h1 id="计算机操作系统">计算机操作系统</h1>
<h2 id="第一章-概述">第一章 概述</h2>
<p>操作系统的定义</p>
<ul>
<li>控制应用程序执行的程序</li>
<li>应用程序和计算机硬件间的接口</li>
</ul>
<p>或者定义为: 一组控制和管理计算机硬件和软件资源, 合理地对各类作业进行调度, 以及方便用户使用的程序的集合</p>
<p>操作系统的目标: 方便 有效 扩展能力</p>
<p>操作系统所处的位置:</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231220150928121.png" alt="image-20231220150928121"></p>
<p>操作系统提供的服务</p>
<ul>
<li>程序开发</li>
<li>程序运行</li>
<li>I/O设备访问</li>
<li>文件访问控制</li>
<li>系统访问</li>
<li>错误检测和响应</li>
<li>记账</li>
</ul>
<p>操作系统控制机制的特殊性</p>
<ul>
<li>与普通软件相同, OS是由处理器执行的一段程序</li>
<li>OS经常会释放控制, 且必须依赖处理器才能恢复控制</li>
</ul>
<p>OS需要完成资源管理</p>
<ul>
<li>内存的分配管理</li>
<li>I/O的访问控制</li>
<li>对文件访问控制和使用</li>
<li>对处理器的分配</li>
</ul>
<p>操作系统的发展过程</p>
<ul>
<li>穿行处理</li>
<li>简单批处理系统</li>
<li>多道批处理系统</li>
<li>分时系统</li>
<li>实时系统</li>
</ul>
<h3 id="串行处理">串行处理</h3>
<p>用户按顺序访问计算机: 串行</p>
<p>调度复杂, 准备时间长</p>
<h3 id="简单批处理系统">简单批处理系统</h3>
<p>监控程序</p>
<ul>
<li>对一批作业进行自动处理</li>
<li>内存中只能同时存放一道作业</li>
</ul>
<p>监控程序的功能</p>
<ul>
<li>作业的自动接续</li>
<li>内存保护: 保护监控程序所在区域</li>
<li>定时器: 防止某作业独占系统</li>
<li>特权指令: 只能由监控程序执行的指令</li>
<li>中断: 早期计算机没有中断功能</li>
</ul>
<p>运行模式</p>
<ul>
<li>用户模式: 不允许执行特权指令</li>
<li>内核模式: 可执行特权指令及访问受保护的内存区域</li>
</ul>
<p>处理器经常处于空闲状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231220155547820.png" alt="image-20231220155547820"></p>
<h3 id="多道批处理系统">多道批处理系统</h3>
<p>简单批处理系统, 处理器必须等待I/O指令完成才能继续处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231220155812394.png" alt="image-20231220155812394"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231220155816800.png" alt="image-20231220155816800"></p>
<p>多道批处理系统:</p>
<ul>
<li>内存中同时存放多个作业</li>
<li>多个作业可并发执行</li>
<li>作业调度程序负责作业的调度</li>
</ul>
<p>多道批处理系统的特征: 多道行, 并行性, 无序性, 无交互能力</p>
<h3 id="分时系统">分时系统</h3>
<ul>
<li>采用多道程序设计技术处理多个交互作业</li>
<li>用户共享终端</li>
<li>不同终端可以同时访问系统</li>
</ul>
<p>分时系统的特征: 多路性, 独立性, 及时性, 交互性</p>
<table>
<thead>
<tr>
<th></th>
<th>批处理系统多道程序设计</th>
<th>分时</th>
</tr>
</thead>
<tbody>
<tr>
<td>主要目标</td>
<td>充分利用处理器</td>
<td>减小响应时间</td>
</tr>
<tr>
<td>操作系统指令源</td>
<td>作业提供命令, 没有用户交互</td>
<td>用户在终端输入命令</td>
</tr>
</tbody>
</table>
<p>第一个分时操作系统: CTSS (Compatible Time-Sharing System)</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231220183834170.png" alt="image-20231220183834170"></p>
<h3 id="实时系统">实时系统</h3>
<p>概念:系统能够及时响应外部事件的请求, 在规定的时间内开始或完成对该事件的处理, 控制实时任务协调运行</p>
<p>实时系统的特征: 可确定性, 可响应性, 用户控制, 可靠性, 故障弱化能力</p>
<h3 id="进程">进程</h3>
<p>概念:</p>
<ul>
<li>一个正在执行的程序</li>
<li>计算机中正在运行的程序的一个实例</li>
<li>可分配给处理器并由处理器执行的一个实体</li>
<li>由下述表征的活动单元:
<ul>
<li>一个单一顺序线程</li>
<li>一个当前状态</li>
<li>一组相关系统资源</li>
</ul>
</li>
</ul>
<p>进程的组成</p>
<ul>
<li>程序</li>
<li>数据, 如变量, 工作空间, 缓冲区</li>
<li>执行上下文
<ul>
<li>进程状态</li>
<li>OS管理和控制进程所需的所有数据</li>
<li>如处理器寄存器的内容, 进程优先级, 是否在等待I/O事件, 在内存中的位置</li>
<li>进程需要数据结构来保存进程的上下文环境</li>
</ul>
</li>
</ul>
<p>存储管理的任务</p>
<ol>
<li>进程隔离</li>
<li>自动分配和管理</li>
<li>支持模块化程序设计</li>
<li>保护盒访问控制</li>
<li>长期存储, 文件系统实现了长期存储, 文件是一个有名称的对象, 也是访问控制和保护的基本单元</li>
</ol>
<p>虚拟存储</p>
<ul>
<li>以逻辑方式访问存储器, 不考虑物理内存可用的空间数量</li>
<li>满足多作业同事主流内存的要求</li>
<li>换入换出机制</li>
<li>分页机制, 解决每个进程大小不同的问题
<ul>
<li>进程由若干个固定大小的块组成, 这就是页</li>
<li>虚地址由页号和页内偏移量组成</li>
<li>每一页都可置于内存中的任何位置</li>
<li>提供了虚地址和内存中实地址间的动态映射机制</li>
</ul>
</li>
<li>每个作业部分驻留在内存时, 硬件检测到缺页时, 安排载入</li>
</ul>
<p>OS的四类安全问题</p>
<ul>
<li>可用性: 系统不被中断</li>
<li>保密性: 未授权不访问数据</li>
<li>数据完整性: 未授权不修改数据</li>
<li>认证: 用户身份的正确认证和消息/数据的合法性</li>
</ul>
<p>资源分配和调度策略需要考虑</p>
<ul>
<li>公平性</li>
<li>有差别的响应性</li>
<li>有效性
<ul>
<li>OS希望有最大吞吐量和最小响应时间</li>
<li>能容纳尽可能多的用户</li>
<li>折中处理矛盾</li>
</ul>
</li>
</ul>
<h3 id="现代操作系统的特征">现代操作系统的特征</h3>
<ol>
<li>微内核</li>
<li>多线程</li>
<li>对称多处理</li>
<li>分布式的操作系统</li>
<li>面向对象的设计</li>
</ol>
<p>微内核: 只给内核分配基本的功能, 如地址空间, 进程间通信, 基本调度</p>
<p>多线程: 一个应用的进程划分为同时运行的多个线程</p>
<ul>
<li>线程
<ul>
<li>可分派的工作单元</li>
<li>包括处理器的上下文环境, 自身的数据区域</li>
<li>顺序执行且可以中断(转到其他线程)</li>
</ul>
</li>
<li>进程
<ul>
<li>一个或多个线程和相关系统资源的集合</li>
</ul>
</li>
</ul>
<p>对称多处理SMP</p>
<ul>
<li>指计算机硬件体系结构, 也指采用该体系结构的操作系统行为</li>
<li>多个进程/线程可以并行运行</li>
<li>多个处理器对用户来讲是透明的
<ul>
<li>多个处理器共享内存和I/O设施</li>
<li>所有处理器可以执行同一任务</li>
</ul>
</li>
<li>操作系统在不同处理器上调度不同的进程/线程, 并负责同步</li>
<li>优点
<ul>
<li>性能好, 多个进程可以再不同的处理器上同时运行</li>
<li>可用性好, 单个处理器失效不会导致机器停止</li>
<li>渐增性好, 系统性能可以随着添加新的处理器而提高</li>
<li>扩展性好, 生产商根据处理器的数量提供不同价格与性能的产品</li>
</ul>
</li>
</ul>
<p>分布式操作系统</p>
<p>面向对象的设计</p>
<ul>
<li>可以模块化扩展小内核</li>
<li>保证代码完整性</li>
<li>开发分布式工具和分布式操作系统更容易</li>
</ul>
<h3 id="容错性">容错性</h3>
<p>提高容错性的技术:</p>
<ul>
<li>进程隔离</li>
<li>并发控制</li>
<li>虚拟机</li>
<li>检测点和回滚机制</li>
</ul>
<h3 id="多处理器和多核操作系统设计考虑因素">多处理器和多核操作系统设计考虑因素</h3>
<p>要提供多道系统的所有功能, 还要提供适应多处理器的额外功能</p>
<p>多核系统设计的常用策略: 应用层并行和虚拟机方式</p>
<h4 id="应用层并行">应用层并行</h4>
<ul>
<li>开发者决定如何分割任务为子任务</li>
<li>操作系统要支持并行编程, 并为子任务分配资源</li>
</ul>
<h4 id="虚拟机方式">虚拟机方式</h4>
<ul>
<li>随着芯片的核的增加, 为一个进程分配一个或多个核</li>
<li>多核操作系统负责为应用程序分配核</li>
</ul>
<h3 id="主流操作系统">主流操作系统</h3>
<ol>
<li>Windows</li>
<li>传统UNIX系统</li>
<li>现代UNIX系统</li>
<li>Linux系统</li>
<li>Android系统</li>
</ol>
<h2 id="第二章-进程管理-1-描述">第二章 进程管理–1. 描述</h2>
<h3 id="进程和进程控制块">进程和进程控制块</h3>
<h4 id="进程">进程</h4>
<p>进程的两个基本元素</p>
<ul>
<li>程序代码</li>
<li>和代码相关的一组数据</li>
</ul>
<p>进程的基本特征</p>
<ul>
<li>动态性, 本质特性</li>
<li>并发性, 重要特性</li>
<li>独立性</li>
<li>异步性, 每个进程的执行速度不一致且不可预知</li>
</ul>
<p>进程和程序的比较</p>
<ul>
<li><strong>进程 = 进程控制块 + 程序 + 相关数据</strong></li>
<li>进程是一个正在执行的程序实例</li>
<li>引入进程的目的是为了使多道程序能正确地并发执行</li>
<li>程序是静态实体, 进程具有动态性</li>
<li>进程与程序不一一对应, 一个应用程序的执行对应一个或多个进程</li>
</ul>
<h4 id="进程控制块">进程控制块</h4>
<p>进程由程序代码, 相关数据和进程控制块组成</p>
<p>进程控制块包括了进程的元素, 可以用来回复中断, 由OS创建和管理是支持多进程的重要工具</p>
<h3 id="进程状态">进程状态</h3>
<p>分派器将处理器从一个进程切换到另一个进程的小程序</p>
<p>处理器的行为可以用多个进程交替执行的轨迹来描述</p>
<h4 id="进程的两状态模型">进程的两状态模型</h4>
<p>三个进程交替执行的轨迹: (这里假设时间片为6个指令周期)</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221011611437.png" alt="image-20231221011611437"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221011619619.png" alt="image-20231221011619619"></p>
<p>此时进程的两状态模型图为</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221011812842.png" alt="image-20231221011812842"></p>
<h4 id="进程的创建与终止">进程的创建与终止</h4>
<h5 id="进程创建">进程创建</h5>
<p>OS创建数据结构, 为进程分配内存</p>
<p>创建原因</p>
<ol>
<li>新的批处理作业</li>
<li>交互登陆, 如终端用户登陆系统</li>
<li>提供服务, 如控制打印进程</li>
<li>由现有进程派生 模块化开发或并行性考虑</li>
</ol>
<p>进程派生: 进程显示地请求创建一个进程, OS创建它的一个子进程</p>
<h5 id="进程终止">进程终止</h5>
<p>批处理作业会包含一个HALT指令或其他显式的OS服务调用来终止进程</p>
<p>用户可以指出交互式的应用程序进程的终止时间</p>
<h4 id="五状态模型">五状态模型</h4>
<p>新建态, 就绪态, 运行态, 阻塞态, 退出态</p>
<p>加载, 调度, 超时, 等待时间, 发生事件, 释放</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221130953711.png" alt="image-20231221130953711"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221131146320.png" alt="image-20231221131146320"></p>
<p>进程的排队模型</p>
<ul>
<li>单阻塞队列: 所有阻塞进程位于一个阻塞队列
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221132350600.png" alt="image-20231221132350600"></li>
</ul>
</li>
<li>多阻塞队列: 一个事件对应一个阻塞队列
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221132404692.png" alt="image-20231221132404692"></li>
</ul>
</li>
</ul>
<h4 id="挂起进程">挂起进程</h4>
<p>竞争内存资源可能导致</p>
<ul>
<li>内存资源紧张</li>
<li>无就绪进程, 处理机空闲</li>
</ul>
<h5 id="交换">交换</h5>
<p>交换: 把内存中的进程部分或全部移到磁盘中, 该进程变为挂起状态, 增加了挂起态</p>
<p>内存紧张/无就绪进程时, 将阻塞进程换出到磁盘的挂起队列, 然后内存从挂起队列取回进程或接纳新进程</p>
<h5 id="挂起">挂起</h5>
<p>被挂起的进程不参与CPU的竞争</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221132846411.png" alt="image-20231221132846411"></p>
<p>但是存在问题: 挂起进程等待的时间没有发生时, 挂起进程取回内存没有意义, 只有挂起进程没有在等待事件时, 此时从内存中取回才是有意义的, 所以引入阻塞/挂起态和就绪/挂起态</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221133053723.png" alt="image-20231221133053723"></p>
<p>挂起进程的特征:</p>
<ol>
<li>进程不能立即执行</li>
<li>进程在等待/没有等待一个事件</li>
<li>进程可能被进程自己, 父进程或OS等代理置为挂起状态</li>
<li>除非代理显式命令进程状态转换, 否则挂起状态不会变化</li>
</ol>
<h3 id="进程描述">进程描述</h3>
<h4 id="操作系统的控制结构">操作系统的控制结构</h4>
<p>操作系统的控制结构 = 内存表 + I/O表 + 文件表 + 进程表</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221154023551.png" alt="image-20231221154023551"></p>
<h5 id="内存表">内存表</h5>
<p>用来跟踪内存和外存</p>
<p>外存中保存的进程使用某种虚拟存储或简单的交换机制</p>
<p>内存表包括</p>
<ul>
<li>分配给进程的内存</li>
<li>分配给进程的外存</li>
<li>内存块或外存块的保护属性, 如为哪些进程共享</li>
<li>管理外存所需要的信息</li>
</ul>
<h5 id="i-o表">I/O表</h5>
<p>进程汇总有I/O操作时, 操作系统必须知道</p>
<ul>
<li>I/O操作的抓你</li>
<li>作为I/O传输数据的源或目标的内存单元</li>
</ul>
<h5 id="文件表">文件表</h5>
<p>文件表包括的信息有:</p>
<ul>
<li>文件是否存在</li>
<li>文件在外存中的位置</li>
<li>当前状态</li>
<li>其他属性</li>
</ul>
<p>文件管理可能由文件管理系统或O自身维护</p>
<h5 id="进程表">进程表</h5>
<p>用来管理进程</p>
<p>表中有对内存, I/O设备和文件的直接/间接引用</p>
<p>进程表本身能被OS访问, 受制于内存管理</p>
<h4 id="进程的控制结构">进程的控制结构</h4>
<p>进程的物理存在是什么</p>
<ul>
<li>
<p>进程位置</p>
<ul>
<li>执行程序</li>
<li>数据</li>
<li>栈</li>
</ul>
</li>
<li>
<p>进程属性</p>
<ul>
<li>
<p>进程控制块PCB, 也即控制属性</p>
</li>
<li>
<p>进程映像, 程序,数据, 栈和属性的集合</p>
<ul>
<li>
<p>用户数据</p>
</li>
<li>
<p>用户程序</p>
</li>
<li>
<p>栈, 每个进程有一个或多个后进先出LIFO栈, 用于保存参数, 过程调用和系统调用地址</p>
</li>
<li>
<p>进程控制块, OS控制进程所需的数据</p>
<ol>
<li>
<p>进程标识信息</p>
<ul>
<li>
<p>每个进程都有唯一的数字标识符</p>
</li>
<li>
<p>可认为是主进程表的索引</p>
</li>
<li>
<p>标识符可以引用进程表, 进程通信时可以标识通信目标, 指明父进程和子进程</p>
</li>
<li>
<p>标识符包括:</p>
<ol>
<li>进程标识符</li>
<li>父进程标识符</li>
<li>用户标识符</li>
</ol>
</li>
</ul>
</li>
<li>
<p>处理器状态信息</p>
<ul>
<li>
<p>由处理器寄存器的内容组成, 包括用户可见寄存器, 控制盒状态寄存器, 栈指针</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221165534488.png" alt="image-20231221165534488"></p>
</li>
<li>
<p>程序状态字寄存器, 包括了条件码(溢出, 进位)和其他状态信息(中断屏蔽, 对齐检查)</p>
</li>
</ul>
</li>
<li>
<p>进程控制信息</p>
<ul>
<li>OS控制和协调各种活动进程所需的额外信息</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>进程映像的位置取决于内存管理方案, 进程映像在虚存中的结构</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221172403142.png" alt="image-20231221172403142"></p>
<h3 id="进程控制">进程控制</h3>
<p>内核, 操作系统的核心</p>
<ul>
<li>OS中包含最重要系统功能的部分</li>
<li>常驻内存, 提高OS运行效能</li>
</ul>
<p>OS内核的功能包括资源管理功能, 支撑功能</p>
<h4 id="内核的资源管理功能">内核的资源管理功能</h4>
<ol>
<li>进程管理
<ul>
<li>进程创建和终止</li>
<li>进程调度和分派</li>
<li>进程切换</li>
<li>进程同步和进程间通信的支持</li>
<li>管理进程控制块</li>
</ul>
</li>
<li>存储管理
<ul>
<li>分配进程的地址空间</li>
<li>交换</li>
<li>页和段管理</li>
</ul>
</li>
<li>I/O设备管理
<ul>
<li>I/O缓冲区的管理</li>
<li>为进程分配I/O通道和设备</li>
</ul>
</li>
</ol>
<h4 id="内核的支撑功能">内核的支撑功能</h4>
<ol>
<li>中断处理</li>
<li>时钟管理, 如时间片控制</li>
<li>记账(统计, 检测)功能</li>
</ol>
<h4 id="执行模式">执行模式</h4>
<p>采用两种模式的原因: 保护OS和重要的操作系统表(如PCB)不受程序干扰</p>
<h5 id="用户模式">用户模式</h5>
<p>具有较少优先权, 用户程序在用户模式下运行</p>
<h5 id="系统模式-内核模式-控制模式">系统模式(内核模式/控制模式)</h5>
<p>与OS相关, 具有更多优先权, 运行OS的内核, 某些指令只能在特权模式下运行, 部分内存只能在特权模式下访问</p>
<p>程序状态字寄存器中存在指示执行模式的位:</p>
<ul>
<li>用户调用OS服务或中断促发系统例程时, 相关位被置为内核模式</li>
<li>从系统服务返回用户进程时, 执行模式置为游戏模式</li>
</ul>
<h4 id="进程创建">进程创建</h4>
<ol>
<li>给新进程分配唯一的进程标识符</li>
<li>为进程分配空间</li>
<li>初始化进程控制块
<ul>
<li>初始化标识信息</li>
<li>初始化处理机状态信息</li>
<li>初始化进程调度信息</li>
</ul>
</li>
<li>建立链接, 将连接插入就绪或就绪/挂起链表</li>
<li>建立或扩充其他数据结构</li>
</ol>
<h4 id="进程切换">进程切换</h4>
<p>进程切换: 调度另一个就绪进程占用处理器执行</p>
<h5 id="系统中断">系统中断</h5>
<ul>
<li>
<p>普通中断</p>
<p>某种独立的外部事件发生导致程序中断, 如时钟中断, I/O中断, 内存失效</p>
<p>时间片: 进程被中断前允许执行的最大运行时间</p>
</li>
<li>
<p>陷阱</p>
<p>当前运行进程内部产生的错误或异常</p>
<p>OS决定错误或异常是否致命, 若是则进程置为退出态, 切换进程; 若否则OS的动作取决于错误的性质</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221223427088.png" alt="image-20231221223427088"></p>
<h5 id="模式切换">模式切换</h5>
<p>模式切换: 用户模式和内核模式间的相互转换</p>
<p>模式切换的原因: 系统调用或中断</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221223957784.png" alt="image-20231221223957784"></p>
<p>模式切换是否会必然导致进程切换?  不一定, 如I/O中断, 某些系统调用不一定会进程切换</p>
<h5 id="进程状态转换">进程状态转换</h5>
<ul>
<li>模式切换可在不改变运行进程状态的情况下出现(内核模式也可以执行用户模式的行为), 进程切换必须改变</li>
<li>改变进程状态, 操作系统必须使环境产生实质变化</li>
</ul>
<p>进程切换的步骤:</p>
<ol>
<li>保存处理器上下文环境, 包括程序计数器和其他寄存器</li>
<li>更新当前进程的进程控制块</li>
<li>将当前进程的进程控制块移到相应队列(就绪, 阻塞, 就绪/挂起)</li>
<li>切换至另一进程, 更新其进程控制块</li>
<li>更新内存管理数据结构</li>
<li>回复被选择进程的上下文环境, 如载入程序计数器和其他寄存器先前的值</li>
</ol>
<h3 id="unix-svr4的进程管理">UNIX SVR4的进程管理</h3>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231221225242853.png" alt="image-20231221225242853"></p>
<h4 id="进程创建">进程创建</h4>
<p>进程创建由内核系统调用fork()实现</p>
<p>OS在内核模式下完成</p>
<ol>
<li>在进程表中为新进程分配一个空项</li>
<li>为子进程分配一个唯一的进程标识符</li>
<li>复制父进程的进程映像</li>
<li>增加父进程拥有的文件计数器, 反应另一个进程现在也拥有这些文件的事实</li>
<li>将子进程设置为就绪态</li>
<li>将子进程的ID号返回给父进程, 0值返回给子进程</li>
</ol>
<p>进程创建后, 内核可继续完成分派器的工作, 具体可能为</p>
<ol>
<li>停留在父进程, 控制权返回到用户模式下父进程调用fork的位置</li>
<li>控制权交给子进程, 执行点为for,k调用返回处</li>
<li>控制权交给其他进程, 父子进程处于就绪态</li>
</ol>
<h4 id="fork">fork</h4>
<p>fork调用格式: pid = fork()</p>
<p>fork()创建子进程后, 父进程和子进程都执行下一条语句</p>
<p>父进程的返回值为子进程的pid, 子进程的返回值为0</p>
<p>父子进程的运行是无关的, 运行顺序不固定</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222002418188.png" alt="image-20231222002418188"></p>
<h3 id="线程">线程</h3>
<h4 id="进程与线程">进程与线程</h4>
<p>进程的两个基本属性</p>
<ul>
<li>拥有资源的独立单位</li>
<li>调度/执行的基本单位</li>
</ul>
<p>多线程: OS在单个进程内支持多个并发路径的能力</p>
<p>单线程方法: 每个进程中只有一个线程在执行</p>
<p>线程: 进程中的一个实体, 是独立调度和分派的基本单位. 每个线程有</p>
<ul>
<li>执行状态(运行, 就绪等)</li>
<li>未运行时保存的线程上下文</li>
<li>执行栈</li>
<li>用于局部变量的静态存储空间</li>
<li>与进程内其他线程共享的内存和资源访问</li>
</ul>
<p>单线程和多线程模式</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222131554411.png" alt="image-20231222131554411"></p>
<p>线程的优点</p>
<ol>
<li>创建线程的时间少于创建进程的时间</li>
<li>终止线程比终止进程时间少</li>
<li>同一进程内线程切换时间少于进程切换时间</li>
<li>现成提高了不同执行程序间通信的效率</li>
</ol>
<p>调度和分派是在线程基础上完成的</p>
<p>线程的主要状态</p>
<ul>
<li>运行</li>
<li>就绪</li>
<li>阻塞</li>
</ul>
<p>和线程状态变化相关的基本操作</p>
<ul>
<li>派生</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>结束</li>
</ul>
<p>单处理器上的多线程示例</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222132358190.png" alt="image-20231222132358190"></p>
<p>线程同步原因</p>
<ol>
<li>一个进程中的所有线程共享一个地址空间和进程的资源</li>
<li>一个线程对共享资源的修改都将影响同一进程其他线程的影响</li>
</ol>
<h4 id="线程分类">线程分类</h4>
<ul>
<li>用户级线程ULT</li>
<li>内核级线程KLT</li>
<li>混合模式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222151126712.png" alt="image-20231222151126712" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222151149356.png" alt="image-20231222151141284" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222151153337.png" alt="image-20231222151153337" style="zoom: 67%;" /></p>
<h5 id="用户级线程ult">用户级线程ULT</h5>
<p>所有线程管理工作由应用程序完成, 内核意识不到线程的存在</p>
<p>用户级线程状态和进程状态间的关系示例(这里进程被阻塞线程还在运行, 是线程库的数据结构没有改变)</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222134133647.png" alt="image-20231222134133647"></p>
<p>用户级线程ULT的优缺点</p>
<ul>
<li>优点
<ol>
<li>线程切换不需要内核模式特权</li>
<li>调度策略因应用程序不同而有所不同</li>
<li>可以运行在任何OS上</li>
</ol>
</li>
<li>缺点
<ol>
<li>典型的OS中, 系统调用会引起进程阻塞. 即某一线程执行系统调用, 同一进程的其他线程都被阻塞</li>
<li>ULT策略和多处理器技术不能同时采用</li>
</ol>
</li>
</ul>
<p>ULT缺点的解决办法: Jacketing技术</p>
<p>将可能产生阻塞的系统调用转换成非阻塞的系统调用, 即将应用程序写成多进程程序而非多线程</p>
<h5 id="内核级线程klt">内核级线程KLT</h5>
<p>线程管理由内核完成, 应用程序没有线程管理的工作, 如Windows</p>
<p>内核级县城KLT的优缺点</p>
<ul>
<li>
<p>优点</p>
<ol>
<li>内核可以把同一进程的多个线程调度到多处理器上</li>
<li>一个线程阻塞时, 内核可以调度同一进程内的其他线程</li>
<li>内核例程本身也可以是多线程的</li>
</ol>
</li>
<li>
<p>缺点</p>
<p>控制权从一个线程给另一个线程时, 需要切换到内核模式</p>
</li>
</ul>
<h5 id="混合方法">混合方法</h5>
<p>线程创建在用户空间完成</p>
<p>线程调度和同步由应用程序完成</p>
<p>一个应用程序中的多个线程被映射到一些内核线程上</p>
<h2 id="第二章-进程管理-2-调度">第二章 进程管理–2. 调度</h2>
<p>如果多个进程/线程竞争CPU, 需要选择下一个要运行的进程/线程, OS中完成这部分工作的程序成为调度程序, 调度程序使用的算法是调度算法</p>
<h3 id="调度的类型">调度的类型</h3>
<ul>
<li>长程调度</li>
<li>中程调度</li>
<li>短程调度</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222154822533.png" alt="image-20231222154822533"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222154836463.png" alt="image-20231222154836463"></p>
<p>具有三种调度的队列模型:</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222154927576.png" alt="image-20231222154927576"></p>
<h4 id="长程调度">长程调度</h4>
<p>决定哪个程序可以进入系统中处理</p>
<p>控制系统中并发的度</p>
<p>从作业队列中选择作业来创建进程, 为此需要考虑</p>
<ul>
<li>何时OS能接纳一个或多个进程</li>
<li>接纳哪个作业创建进程
<ul>
<li>先来先服务</li>
<li>优先级, 期望执行时间, I/O需求</li>
</ul>
</li>
</ul>
<h4 id="中程调度">中程调度</h4>
<p>交换功能的一部分</p>
<p>换入决定取决于系统并发度的需求</p>
<p>在不适用虚存的系统中, 换入决策要考虑换出进程的存储需求</p>
<h4 id="短程调度">短程调度</h4>
<p>称为分派程序, 执行最频繁, 精确决定下次执行哪个进程</p>
<p>导致当前进程阻塞或抢占当前运行进程的事件发生时, 调用短程调度程序</p>
<p>事件可能包括: 时钟中断, I/O中断, 系统调用, 信号, 如信号量</p>
<p>短程调度的主要目标: 按照优化系统某些方面的方式, 来分配处理器时间</p>
<h3 id="调度的规则">调度的规则</h3>
<p>与调度规则相关的概念</p>
<ul>
<li>响应时间: 从用户提交请求开始到接收响应之间的时间间隔
<ul>
<li>响应时间 = 输入传送时间 + 处理时间 + 响应传送时间</li>
</ul>
</li>
<li>周转时间(驻留时间): 一个进程从提交到完成之间的时间间隔
<ul>
<li>周转时间 = 等待资源的时间 + 执行时间, 等待资源包括处理器资源</li>
</ul>
</li>
<li>截止时间: 任务开始执行的最迟时间, 或必须完成的最迟时间</li>
<li>吞吐量: 单位时间内, 系统完成的进程数</li>
<li>处理器利用率: 处理器处于忙状态的时间百分比</li>
</ul>
<h4 id="计算">计算</h4>
<p>周转时间: 一个进程从提交到完成之间的时间间隔</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>周转时间</mtext><mo>=</mo><mtext>等待资源的时间</mtext><mo>+</mo><mtext>执行时间</mtext></mrow><annotation encoding="application/x-tex">周转时间 = 等待资源的时间 + 执行时间
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">资</span><span class="mord cjk_fallback">源</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span></span></p>
<p>平均周转时间: 多个进程周转时间的平均值</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222161506306.png" alt="image-20231222161506306"></p>
<p>带权周转时间: 进程的周转时间与系统为它提供的服务时间之比</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222161938229.png" alt="image-20231222161938229"></p>
<p>平均带权周转时间:多个进程带权周转时间的平均值</p>
<h3 id="调度规则的划分">调度规则的划分</h3>
<ul>
<li>
<p>面向用户, 与性能相关</p>
<p>周转时间, 响应时间, 最后期限</p>
</li>
<li>
<p>面向用户, 与性能无关</p>
<p>可预测性</p>
</li>
<li>
<p>面向系统, 与性能相关</p>
<p>吞吐量, 处理器利用率</p>
</li>
<li>
<p>面向系统, 与性能无关</p>
<p>公平性, 强制优先级, 平衡资源</p>
</li>
</ul>
<p>优先级的使用: 考虑进程优先级可能导致饥饿, 可以采用动态优先级方案</p>
<h3 id="调度的决策模式">调度的决策模式</h3>
<ul>
<li>
<p>非抢占</p>
<p>只有在进程执行完毕或申请I/O或请求OS服务而阻塞自己时才释放处理机</p>
</li>
<li>
<p>抢占</p>
<p>执行进程可能被OS中断, 并转换为就绪态</p>
<p>抢占可能发生在</p>
<ul>
<li>新进程到达时</li>
<li>中断发生后把一个阻塞进程置为就绪态</li>
<li>周期性的时钟中断</li>
</ul>
</li>
</ul>
<p>调度的选择函数</p>
<p>基于优先级, 资源需求或进程的执行特性, 选择下次执行哪个就绪进程</p>
<p>基于执行特性时的关键参数</p>
<ul>
<li>w = 等待时间</li>
<li>e = 目前的执行时间</li>
<li>s = 进程的总服务时间, 包括e; 这个参数需要估计或由用户提供</li>
</ul>
<h3 id="调度算法">调度算法</h3>
<ul>
<li>先来先服务FCFS, 也称FIFO</li>
<li>时间片轮转RR</li>
<li>短作业优先SPF/SJF/SPN</li>
<li>剩余时间最短优先SRT</li>
<li>响应比高者优先HRRN</li>
<li>反馈Feedback</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222164228428.png" alt="image-20231222164228428"></p>
<h4 id="先来先服务first-come-first-served-fcfs">先来先服务First-Come-First-Served(FCFS)</h4>
<p>评价:</p>
<ul>
<li>
<p>非抢占调度方式</p>
</li>
<li>
<p>利于CPU繁忙型进程, 不利于I/O进程</p>
</li>
<li>
<p>不适合单处理器系统, 适合和其他调度算法混合使用</p>
</li>
<li>
<p>平均周转时间长</p>
</li>
<li>
<p>长进程有利, 不利于短进程</p>
</li>
</ul>
<h4 id="时间片轮转调度算法round-robin-rr">时间片轮转调度算法Round Robin(RR)</h4>
<p>RR在通用的分时系统或事务处理系统中很有效</p>
<p>计算中要注意, 如果一个进程时间片结束的同时有一个新进程, 刚结束的进程在队列中要排到新进程后面</p>
<p>评价:</p>
<ul>
<li>非抢占调度方式</li>
<li>常用于分时系统或事务处理系统</li>
<li>时间片的设置与系统性能, 响应时间密切相关
<ul>
<li>时间片太短, 进程切换频繁, 降低CPU效率</li>
<li>时间片太长, 短交互请求的响应时间变长</li>
<li>时间片最好略大于一次典型的交互时间</li>
</ul>
</li>
<li>对CPU密集型进程有力, 对I/O密集型进程不利
<ul>
<li>CPU密集型进程可以充分利用时间片</li>
<li>I/O密集型进程每次短时间使用CPU, 然后I/O阻塞, I/O操作后加入就绪队列, 若有CPU密集型在前面, 则需要长时间等待</li>
<li>CPU密集型进程不公平地使用了大部分CPU时间, 导致I/O密集型进程性能下降</li>
</ul>
</li>
</ul>
<h5 id="rr算法的改进-vrr算法">RR算法的改进: VRR算法</h5>
<p>增加一个辅助队列, 接受I/O阻塞完成的进程, 调度优先于就绪队列, 但占用的处理机时间小于就绪队列的时间片</p>
<h4 id="短进程优先shortest-job-process-first-next-sjf-spf-spn">短进程优先Shortest Job/Process First/Next(SJF/SPF/SPN)</h4>
<p>短进程或短作业优先调度, 前提是执行时间可以预知</p>
<p>评价:</p>
<ul>
<li>非抢占调度方式</li>
<li>短进程跳到队列头, 可能导致长进程饥饿</li>
<li>有利于短进程, 减小了平均周转时间</li>
<li>缺少抢占机制, 不适用于分时系统或事务处理环境</li>
<li>进程的长短根据用户提供的估计执行时间确定, 可能由于用户估计不准时而做不到真正的短作业优先调度</li>
</ul>
<h4 id="剩余时间最短者优先算法shortest-remaining-time-srt">剩余时间最短者优先算法Shortest Remaining Time(SRT)</h4>
<p>调度程序总是选择预期剩余时间最短的进程, 在SJF的基础上增加了抢占机制</p>
<p>评价</p>
<ul>
<li>优点
<ol>
<li>不像FCFS偏爱长进程, 也不限购RR产生额外的中断, 从而减少了开销</li>
<li>周转时间方面SRT比SJF性能要好, 短进程只要就绪就可以被立即选择执行</li>
</ol>
</li>
<li>缺点
<ol>
<li>需要估计预期的服务时间</li>
<li>存在长进程饥饿现象</li>
<li>必须记录进程的已服务时间</li>
</ol>
</li>
</ul>
<h4 id="响应比高者优先highest-response-ratio-next-hrrn">响应比高者优先Highest Response Ratio Next(HRRN)</h4>
<p>当前进程执行完毕或需要阻塞时, 选择响应比最高的进程执行</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>p</mi></msub><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>服务时间</mtext></mrow><mtext>服务时间</mtext></mfrac><mo>=</mo><mfrac><mrow><mi>w</mi><mo>+</mo><mi>s</mi></mrow><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">R_p = \frac{等待时间 + 服务时间}{服务时间} = \frac{w+s}{s}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9463300000000001em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>评价:</p>
<ul>
<li>实质是一种动态优先权调度算法</li>
<li>是FCFS和SJF的结合, 既照顾了短进程, 也考虑了作业到达的先后次序, 不会使长进程长期得不到服务</li>
<li>每次调度前, 都要计算响应比, 增加系统开销, 且难以准确计算</li>
</ul>
<h4 id="反馈调度法feedback-fb">反馈调度法Feedback(FB)</h4>
<p>SJF, SPT, HRRN: 采用了&quot;奖励短进程&quot;的思想, 但是基于进程的预期执行时间–未来</p>
<p>FB:</p>
<ul>
<li>采用&quot;乘法运行时间较久进程&quot;的思想</li>
<li>关注的是&quot;已经执行&quot;的时间</li>
<li>根据进程执行历史, 调度基于抢占原则(按时间片)</li>
<li>采用动态优先级机制, 可以获得较好的性能</li>
</ul>
<p>FB采用多级队列区别对待的方法&quot;惩罚长进程&quot;</p>
<ul>
<li>多个独立的, 优先级不同的就绪队列</li>
<li>各队列区别对待, 即优先调度优先级高的队列</li>
<li>进程执行过程中可降级, 即在整个生命周期内可能位于不同队列</li>
</ul>
<p>FB有多个变种, 区别主要在于抢占机制不同</p>
<h5 id="基于时间片轮转的反馈调度算法">基于时间片轮转的反馈调度算法</h5>
<ol>
<li>设置多个就绪队列, 每个队列赋予不同优先级
<ul>
<li>第一队列优先级最高, 依次递减</li>
<li>各个队列中进程执行的时间片不相同, 优先级越高的队列, 时间片越小</li>
</ul>
</li>
<li>新进程进入时, 放入第一个队列尾, 按FCFS原则排队</li>
<li>若进程在时间片内完成则退出. 从队列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>中调度的进程允许执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>的时间, 然后才被抢占, 降级到下一个优先级队列</li>
<li>到达最低优先级队列后, 不再降级</li>
<li>仅当第一队列空闲时, 才调度第二队列中的进程, 以此类推</li>
</ol>
<p>评价:</p>
<ul>
<li>
<p>多级反馈队列调度算法具有较好的性能, 能较好地满足各种类型用户的需要</p>
</li>
<li>
<p>有利于终端型作业用户</p>
<p>常为短作业, 能在第一队列规定的时间片内完成</p>
</li>
<li>
<p>对短作业用户有利</p>
<p>能在前几个队列规定的时间片内完成</p>
</li>
<li>
<p>长进程</p>
<p>随着优先级的下降, 分配的时间片长度增肌, 减少了抢占次数</p>
</li>
<li>
<p>问题: 不断有新进程到来时, 长进程可能饥饿</p>
</li>
</ul>
<h3 id="实时系统与实时调度">实时系统与实时调度</h3>
<h4 id="实时系统">实时系统</h4>
<p>系统能及时响应外部事件的请求, 在规定时间内完成对该时间的处理, 并控制所有实时任务协调一致地运行</p>
<p>对实时系统而言, 系统的正确性不仅取决于计算的结果, 还依赖于产生结果的时间</p>
<p>截止时间</p>
<ul>
<li>开始截止时间: 任务在某时间以前, 必须开始执行</li>
<li>完成截止时间: 任务在某时间以前必须完成</li>
</ul>
<p>实时任务分类</p>
<ul>
<li>有截止时间
<ul>
<li>硬实时任务</li>
<li>软实时任务</li>
</ul>
</li>
<li>周期性/非周期性
<ul>
<li>周期性实时任务</li>
<li>非周期性实时任务</li>
</ul>
</li>
</ul>
<p>实时操作系统特点</p>
<ul>
<li>可确定性: 任务按照固定的预先确定的时间或时间间隔进行</li>
<li>可响应性: 关注系统在知道中断后为中断提供服务的时间</li>
<li>用户控制: 用户能区分软/硬实时任务, 并控制任务优先级</li>
<li>可靠性: 实时响应和控制事件, 保障性能</li>
<li>失效弱化: 系统具有稳定性, 当不能满足所有任务的实时性时, 首先满足重要的/优先级高的任务期限</li>
</ul>
<h4 id="实时调度的调度方法">实时调度的调度方法</h4>
<p>调度的方法: 下次调度哪个人物</p>
<p>抢占的烈性: 调度时采用什么抢占方式</p>
<p>实时调度方法</p>
<ul>
<li>静态表驱动调度法</li>
<li>静态优先级抢占调度法</li>
<li>基于动态规划的调度法</li>
<li>动态尽力调度法</li>
</ul>
<h5 id="静态表驱动调度法">静态表驱动调度法</h5>
<p>调度周期性实时任务</p>
<p>制订调度表以调度实时任务, 依据有到达时间, 执行时间, 完成截止时间和任务优先级</p>
<p>最早截止时间优先(EDF)调度算法属于此类</p>
<p>算法不灵活</p>
<h5 id="静态优先级抢占调度法">静态优先级抢占调度法</h5>
<p>调度非实时多道程序系统</p>
<p>需要确定优先级, 如在分时系统中可以对I/O和CPU密集型的进程赋予不同的优先级</p>
<p>实时系统中根据任务的时间约束赋予优先级</p>
<h5 id="基于动态规划的调度法">基于动态规划的调度法</h5>
<p>实时任务到达后, 系统为新到达的任务和正在执行的任务动态创建一张调度表</p>
<p>在当前执行进程不会超时的条件下, 若也能让新任务在截止时间内完成, 立即调度新任务</p>
<h5 id="动态尽力调度法">动态尽力调度法</h5>
<p>用于非周期性实时任务调度</p>
<p>任务到达时, 系统根据其属性赋予优先级, 优先级高的先调度</p>
<p>缺点是, 当任务完成或截止时间到达时, 很难知道该任务是否满足其约束时间</p>
<h4 id="实时调度的抢占方法">实时调度的抢占方法</h4>
<ul>
<li>基于时间片的轮转抢占式调度</li>
<li>基于优先级的非抢占式调度</li>
<li>基于优先级的抢占点抢占调度</li>
<li>立即抢占式调度</li>
</ul>
<h5 id="基于时间片的轮转调度-属于抢占方式">基于时间片的轮转调度(属于抢占方式)</h5>
<p>实时进程按时间片轮转方式执行, 到达的实施进程放在就绪队列尾</p>
<p>新到的进程的时间片到时调度</p>
<p>响应时间一般为秒级</p>
<p>广泛用于分时系统及一般实时处理系统</p>
<h5 id="基于优先级的非抢占调度">基于优先级的非抢占调度</h5>
<p>实时进程按优先级/非抢占方式执行, 新到的实时进程放在就绪队列首部</p>
<p>当前进程阻塞或完成时, 立即调度新到进程</p>
<p>响应时间一般在数百毫秒至数秒范围</p>
<p>多用于多道批处理系统及不太严格的实时系统</p>
<h5 id="基于优先级的抢占点抢占调度">基于优先级的抢占点抢占调度</h5>
<p>实时进程按优先级, 抢占方式执行</p>
<p>当下一个抢占点到来时, 立即占用CPU</p>
<p>响应时间一般在几毫秒至几十毫秒</p>
<p>用于一般实时系统</p>
<h5 id="立即抢占式调度">立即抢占式调度</h5>
<p>实施进程按优先级, 抢占方式执行</p>
<p>响应时间为微秒至毫秒级</p>
<p>可用于苛刻的实时系统</p>
<h4 id="实时调度示例">实时调度示例</h4>
<p>实时调度基于实时任务的信息, 如就绪时间, 启动限期, 完成限期, 处理时间, 资源需求, 优先级, 子任务结构</p>
<p>子任务结构: 一个任务可分解为一个必须执行的子任务和可选执行子任务, 前者有硬截止时间</p>
<p>下次调度哪个人物?    选择ddl最早的任务调度</p>
<p>采用什么抢占方式?    启动限期明确的任务, 采用飞抢占方式; 对于有完成限期的实时系统, 采用抢占策略</p>
<h5 id="针对具有完成限期的周期性实时任务调度示例">针对具有完成限期的周期性实时任务调度示例</h5>
<p>此类任务是周期性的, 可预测的</p>
<p>采用最早截止时间有限调度算法Earliest Deadline First(EDF)</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222223545330.png" alt="image-20231222223545330"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222223534375.png" alt="image-20231222223534375"></p>
<h5 id="针对具有开始限期的非周期性实时任务">针对具有开始限期的非周期性实时任务</h5>
<p>此类任务是非周期性的, 不可预测, 采用EDF算法存在危险性</p>
<p>若在任务就绪前, 预先知道任务的开始截止时间, 可以采用允许CPU空闲的EDF调度算法</p>
<h6 id="允许cpu空闲的edf调度算法">允许CPU空闲的EDF调度算法</h6>
<p>优先调度截止时间最早的合格任务, 并让该任务运行完毕</p>
<p>合格任务可以是还未就绪, 但是事先知道其开始截止时间的任务</p>
<p>CPU的利用率不高, 但这种调度算法可以保证系统中的任务按要求完成</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222223503737.png" alt="image-20231222223503737"></p>
<h5 id="速率单调调度算法rate-monotonic-scheduling-rms">速率单调调度算法Rate Monotonic Scheduling(RMS)</h5>
<p>针对周期性任务</p>
<p>任务速率: 任务周期(以秒记)的倒数, 以赫兹为单位</p>
<p>优先级的确定</p>
<ul>
<li>任务周期越短, 优先级越高</li>
<li>优先级函数式任务速度的单调递增的函数</li>
</ul>
<p>系统按任务优先级的高低进行调度</p>
<h5 id="实时系统处理能力限制">实时系统处理能力限制</h5>
<p>假定系统中有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个周期性的硬实时任务, 任务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的处理时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 周期为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 在单处理机情况下, 必须满足:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>P</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum^m_{i=1}\frac{C_i}{P_i}\leq 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>CPU的利用率 = 任务执行时间爱你 / 任务周期, 上式表示系统中各个任务的处理器总利用率不超过1</p>
<h5 id="优先级翻转">优先级翻转</h5>
<p>一种错误的调度状态, 高优先级任务简介被低优先级任务抢占</p>
<p>解决: 优先级集成, 优先级较低的任务继承任何与其共享统一资源的优先级较高的任务的优先级</p>
<h2 id="第二章-进程管理-3-同步">第二章 进程管理–3. 同步</h2>
<h3 id="并发的原理">并发的原理</h3>
<p>多道程序设计为什么需要同步?</p>
<ul>
<li>进程时计算机中的独立个体, 具有异步性, 并发性</li>
<li>资源是计算机中的稀缺个体, 需共享, 如CPU, 内存, I/O设备</li>
<li>进程间可能需要写作完成任务</li>
</ul>
<p>并发相关的关键术语</p>
<ul>
<li>原子操作: 一个或多个指令实现的动作或函数, 对外不可见, 要不都执行, 要么都不执行</li>
<li>互斥: 临界区同时只能有一个进程访问</li>
<li>临界资源: 不可同时访问, 必须互斥访问</li>
<li>临界区: 访问临界资源的代码, 任意时刻只能由一个进程在这段代码中运行</li>
<li>忙等现象: 一个进程等待进入临界区, 会继续消耗处理器的时间</li>
<li>活锁: 两个或两个以上的进程为响应其他进程而改变自己的状态, 不做有用工作的情形</li>
<li>死锁: 两个或两个以上的进程因等待其他进程做完某些事而不能继续执行的情形</li>
<li>竞争条件: 多个进程或线程读写共享数据时, 结果取决于多个进程的指令执行顺序</li>
<li>饥饿: 可以执行的进程被调度程序无限期忽视而不能执行的情形</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231222231936372.png" alt="image-20231222231936372" style="zoom:67%;" />
<p>进程的相对执行速度不可预测, 取决于</p>
<ul>
<li>其他进程的活动</li>
<li>OS处理中断的方式</li>
<li>OS的调度策略</li>
</ul>
<p>进程执行的速度补课预测, 给并发嗲来了困难</p>
<ul>
<li>资源共享充满了危险</li>
<li>OS需要优化管理资源的分配</li>
<li>定位程序的设计错误很困难</li>
</ul>
<h3 id="进程间的交互方式">进程间的交互方式</h3>
<ul>
<li>竞争, 彼此不知道对方存在</li>
<li>通过共享合作, 彼此直到对方存在</li>
<li>通过通信合作</li>
</ul>
<h4 id="竞争">竞争</h4>
<ul>
<li>进程间不知道彼此存在</li>
<li>进程竞争使用同一资源时会发生冲突</li>
<li>如I/O设备, 存储器, 处理器, 始终</li>
</ul>
<p>竞争资源时, 并发控制面临三个问题:</p>
<ul>
<li>互斥</li>
<li>死锁</li>
<li>饥饿</li>
</ul>
<h4 id="进程间通过共享合作">进程间通过共享合作</h4>
<p>多个进程共享资源</p>
<p>一个进程的结果可能取决于另一个进程</p>
<p>进程知道其他进程可能共享同一个数据, 因此必须合作</p>
<p>共享合作可能有四个问题</p>
<ul>
<li>互斥</li>
<li>死锁</li>
<li>饥饿</li>
<li>数据一致性</li>
</ul>
<h4 id="进程间通过通信合作">进程间通过通信合作</h4>
<p>进程间通过通信完成同步和协调彼此活动</p>
<p>一个进程的结果可能取决另一个进程</p>
<p>通信可由各种类型的消息组成</p>
<p>不涉及对共享资源的访问</p>
<p>通信合作可能有两个问题</p>
<ul>
<li>死锁</li>
<li>饥饿</li>
</ul>
<h3 id="互斥">互斥</h3>
<p>互斥的要求</p>
<ol>
<li>空闲让进: 若临界区空闲, 有进程申请就进入</li>
<li>忙则等待: 每次只允许一个进程处于临界区</li>
<li>有限等待: 保证进程有限时间内能进入临界区(不会死锁或饥饿)</li>
<li>让权等待: 进程在临界区不能长时间阻塞等待某事件</li>
</ol>
<h4 id="互斥实现的软件方法">互斥实现的软件方法</h4>
<p>在进入区设置和检查一些标志来判断是否有进程在临界区</p>
<p>软件方法评价:</p>
<ul>
<li>始终不能解决忙等现象, 降低系统效率</li>
<li>采用软件方法实现进程互斥使用临界资源比较困难, 两个容易但多个困难</li>
<li>算法设计需要非常小心, 否则可能出现死锁, 或互斥失败等严重问题</li>
</ul>
<h4 id="互斥实现的硬件方法">互斥实现的硬件方法</h4>
<ul>
<li>中断禁用</li>
<li>机器指令
<ul>
<li>compare &amp; swap</li>
<li>Exchange</li>
</ul>
</li>
</ul>
<h5 id="中断禁用-屏蔽中断">中断禁用(屏蔽中断)</h5>
<p>用于单处理器系统</p>
<p>通过禁用中断, 避免进程切换, 实现互斥访问</p>
<p>缺点:</p>
<ul>
<li>
<p>执行效率明显下降</p>
<p>无法响应外部请求, 无法切换进程</p>
</li>
<li>
<p>无法在多处理器环境下工作</p>
<p>不能实现互斥</p>
</li>
</ul>
<h5 id="专用机器指令">专用机器指令</h5>
<ul>
<li>
<p>多处理器环境中, 几个处理器共享访问公共主存</p>
</li>
<li>
<p>处理器表现出一种对等关系, 不存在主从关系</p>
</li>
<li>
<p>处理器之间没有支持互斥的中断机制</p>
</li>
<li>
<p>处理器的设计者提出了一些机器指令, 用于保证两个动作的原子性</p>
<p>如在一个周期中对一个存储器单元的读和写</p>
<p>这些动作在一个指令周期中执行, 不会被打断和干扰</p>
</li>
</ul>
<h6 id="比较和交换指令-compare-swap-compare-exchange">比较和交换指令 compare &amp; swap （compare&amp;exchange）</h6>
<p>比较内存单元的值和一个测试, 若相等, 则发生交换</p>
<p>Exchange指令: 原子性地交换寄存器和内存的值</p>
<p>专用机器指令评价:</p>
<ul>
<li>优点
<ol>
<li>支持多处理机</li>
<li>简单, 易证明</li>
<li>支持多临界区</li>
</ol>
</li>
<li>缺点
<ol>
<li>忙等现象</li>
<li>可能饥饿</li>
<li>可能死锁</li>
</ol>
</li>
</ul>
<h3 id="信号量">信号量</h3>
<p>信号量实现进程互斥与同步的基本原理</p>
<ul>
<li>
<p>两个或多个进程可以通过传递信号进行合作</p>
<p>迫使进程在某个位置暂时停止执行(阻塞), 直到收到一个可以向前推进的信号(被唤醒)</p>
</li>
<li>
<p>信号量可视为一个值为整数的变量</p>
</li>
<li>
<p>信号量可以分为二元信号量(0或1), 计数信号量(非二元信号量/一般信号量), 都用队列来组织等待信号量的进程</p>
</li>
</ul>
<p>只有以下三个操作可以检查或操作信号量</p>
<ol>
<li>信号量初始化为非负数</li>
<li>semWait(Wait或P)使信号量-1, 若值为负数, 则阻塞执行semWait(Wati或P)的进程</li>
<li>semSignal(Signal或V)使信号量+1, 若值$\leq$0, 则解除执行semWait(Wait或P)的进程的阻塞状态</li>
</ol>
<p>根据组织方式不同, 可分为</p>
<ul>
<li>强信号量: 进程以FIFO方式从队列里移除
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231223105406470.png" alt="image-20231223105406470"></li>
</ul>
</li>
<li>弱信号量: 未规定阻塞进程从队列里移除的顺序</li>
</ul>
<p>信号量的实现</p>
<ul>
<li>semWait和semSignal作为原语实现</li>
<li>任意时刻只能有一个进程用semWait和semSignal来操作控制信号量</li>
<li>可以通过硬件/固件实现, 或采用硬件指令支持来保证进程互斥使用semWait或semSignal操控信号量</li>
</ul>
<p>信号量的count值可以解释为</p>
<ul>
<li>s.count$\geq$0, s.count表示执行semWati操作而不则色的进程数(或看做可用资源数), 这种情形信号量可支持同步与互斥</li>
<li>s.count$\leq$0, s.count表示阻塞在s.queue队列上的进程数</li>
</ul>
<p>经典同步问题有</p>
<ol>
<li>生产者/消费者问题</li>
<li>理发师问题</li>
<li>读/写者问题</li>
<li>哲学家就餐问题</li>
</ol>
<h3 id="生产者与消费者问题">生产者与消费者问题</h3>
<p>描述</p>
<ul>
<li>一个或多个生产者产生数据并放入缓冲</li>
<li>消费者从缓冲中互斥取出数据</li>
<li>生产者或消费者互斥访问缓冲</li>
</ul>
<p>需解决的同步问题</p>
<ul>
<li>保证缓冲区满时, 生产者不会往缓冲区中增加数据</li>
<li>保证缓冲区空时, 消费者不能从缓冲区中取走数据</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231223113952521.png" alt="image-20231223113952521"></p>
<h4 id="代码">代码</h4>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231223143358391.png" alt="image-20231223143358391" style="zoom:80%;" />
<p><strong>应先申请资源信号量, 再申请互斥信号量, 顺序不能颠倒</strong></p>
<p>同一个进程中的多个signal语句颠倒会使性能下降</p>
<p>同一个信号量的wait与signal操作, 可以出现在同一进程或不同进程中</p>
<p>对任何信号量的wait与signal操作必须配对</p>
<h4 id="示例1分析">示例1分析</h4>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231223143958631.png" alt="image-20231223143958631" style="zoom:50%;" />
<p>定义互斥信号量mutex</p>
<p>定义产品资源信号量orange, apple, 爸爸儿子因桔子的放入或取出而同步, 爸爸女儿因苹果的放入或取出而同步</p>
<p>设置空间资源信号量empty, 爸爸儿子女儿共享盘子</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231223144749402.png" alt="image-20231223144749402"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231223144804142.png" alt="image-20231223144804142"></p>
<h4 id="示例2分析">示例2分析</h4>
<p>两个生产者和两个消费者被连接到大小为1的缓冲区上</p>
<p>设置资源信号量plate, 盘子是一互斥访问的空间资源</p>
<p>设置产品信号量apple, 爸爸女儿因为苹果的放入或取出而同步</p>
<p>设置产品信号量orange, 妈妈儿子因为桔子的放入与取出而同步</p>
<h4 id="示例3分析">示例3分析</h4>
<p>两个生产者和一个消费者被连接到大小为2的缓冲区上</p>
<p>设置空间资源信号量empty_apple, 盘子中是否可以放入苹果</p>
<p>设置空间资源信号量empty_orange, 盘子中是否可以放入桔子</p>
<p>设置产品资源信号量apple, 盘子中是否可以取出苹果</p>
<p>设置产品资源信号量orange, 盘子中是否可以取出桔子</p>
<h4 id="示例4分析">示例4分析</h4>
<p>一个生产者进程和两个消费者进程共享大小为1的缓冲区, 当且仅当缓冲为空时, 生产者进程负责加入数据, 当且仅当缓冲有数据时, 消费者读数据, 只有两个消费者都读取数据后, 生产者才能删除原有数据并继续生产下一个数据</p>
<p>一个生产者和两个消费者, 一幅画要给两个人看; 可看作一个生产者每次针对不同消费者生产两个数据</p>
<p>两个数据都被消费后才能继续生产</p>
<p>设置空间资源信号量empty_dad, 爸爸是否欣赏过</p>
<p>设置产品资源信号量full_dad, 爸爸是否可以欣赏</p>
<p>设置空间资源信号量empty_mom, 妈妈是否欣赏过</p>
<p>设置产品资源信号量full_mom, 妈妈是否可以欣赏</p>
<h3 id="读者和写者问题">读者和写者问题</h3>
<p>描述</p>
<ul>
<li>多个进程访问一个共享数据区(可为文件, 内存空间, 寄存器)</li>
<li>读进程只能读, 写进程只能写</li>
<li>为数据库, 文件, 内存区及一组寄存器等的数据访问问题建立了一个通用模型</li>
<li>三个角色: 读进程, 写进程, 共享数据</li>
<li>三个条件: 同时读, 互斥写, 互斥读写</li>
</ul>
<p>如何判断一个问题是生产者/消费者问题还是读者/写者问题</p>
<ul>
<li>
<p>生产者/消费者问题: 数据消费后没有了</p>
<p>读者/写者问题: 数据可以多次读</p>
</li>
<li>
<p>生产者/消费者问题: 消费者彼此互斥</p>
<p>读者/写者问题: 读者可以同时读</p>
</li>
<li>
<p>生产者/消费者问题: 生产者/消费者间有互斥关系和同步关系</p>
<p>读者/写者问题: 读者/写者之间有互斥关系</p>
</li>
</ul>
<p>解决策略</p>
<ul>
<li>读者优先</li>
<li>写者优先</li>
<li>公平读写</li>
</ul>
<h4 id="读者优先">读者优先</h4>
<p>若有读者正在读数据, 允许后面的读者读数据</p>
<p>只有所有读者退出 才允许写者写数据</p>
<p>可能导致写者饥饿</p>
<h5 id="读者优先的变量设置">读者优先的变量设置</h5>
<p>wsem: 互斥信号量, 用于Writers间互斥, Writers和Readers互斥</p>
<p>readcount: 统计同时读数据的Readers个数</p>
<p>x: 对变量readcount互斥算术操作</p>
<h4 id="公平读写">公平读写</h4>
<p>写过程中, 若其他读者写者到来, 按到达顺序处理</p>
<h5 id="公平读写的变量设置">公平读写的变量设置</h5>
<p>wsem: 互斥信号量, 用于Writers间互斥, Reader互斥Writers</p>
<p>x: 对于变量readcount互斥算术操作</p>
<p>wrsem: 互斥信号量, 确定Writer, Reader请求顺序</p>
<p>在读者优先中, wsem只对第一个读者起阻塞作用, 后续读者不受影响, 为了爆照按照到达顺序处理, 公平优先方式设置wrsem, 读者/写者按到达顺序在wrsem上排队</p>
<h4 id="写者优先">写者优先</h4>
<p>至少一个写者想写数据时, 不允许新的读者进入读数据</p>
<p>例如(队列尾)WWRRW(队列头), 让三个W进程能优先于R进程写数据</p>
<p>解决了写者饥饿问题, 降低了必发成都, 系统的并发性能比较差</p>
<h5 id="写者优先的变量设置">写者优先的变量设置</h5>
<p>rsem: 互斥信号量, 至少有一个写者申请写数据时互斥新的读者进入读数据</p>
<p>第一个写者受rsem影响, 一旦有第一个写者, 需写者不受rsem影响, 但是读者需要再rsem上排队</p>
<p>writecount: 用于控制rsem信号量</p>
<p>y: 对变量writecount互斥算术操作</p>
<h5 id="写者优先的改进">写者优先的改进</h5>
<p>添加z信号量, 作用:</p>
<ul>
<li>在rsem上不允许建造读进程的长队列, 否则写进程将不能跳过这个队列</li>
<li>允许一个读进程在rsem上排队, 其他读进程在信号量z上排队</li>
</ul>
<h4 id="示例1">示例1</h4>
<p>多个写者共享数据, 行人-写者, 桥-共享数据</p>
<p>s: 互斥信号量, 用于写者互斥</p>
<h4 id="示例2">示例2</h4>
<p>两组读者, 同一组内部可以同时读, 不同组之间互斥, 即只要有一组读者上桥, 同组读者优先于另一组读者</p>
<p>桥–共享数据</p>
<p>x: 互斥信号量, 用于两组读者的互斥</p>
<p>countR: 统计读者数目(同时在桥上的行人数目)</p>
<p>mutexR: 对变量countR互斥算术操作</p>
<h4 id="示例3">示例3</h4>
<p>读者优先问题</p>
<p>行人首先上桥的一方为读者, 另一方为写者</p>
<p>桥–共享数据</p>
<p>x: 互斥信号量, 用于读者互斥写者</p>
<p>countR: 统计读着数目(同一方向要过桥的行人数目)</p>
<p>mutexR: 对变量countR互斥算术操作</p>
<p>count: 位于独木桥上的行人数目</p>
<h3 id="理发师睡觉问题">理发师睡觉问题</h3>
<p>傻逼, 看不懂, 睡觉吧</p>
<h3 id="管程">管程</h3>
<p>信号量可以高效的实现进程间互斥与同步, 但是信号量的PV操作可能分散在整个程序中, 使用难度高</p>
<p>管程是一个程序设计语言结构, 采用了集中式的进程同步方法, 提供了与信号量同样的功能, 但更易于控制</p>
<p>管程</p>
<ul>
<li>管程定义了一个共享数据结构和并发程序能执行的一组操作, 这组操作能同步进程和改变管程中的数据</li>
<li>共享数据结构是对系统中共享资源的抽象</li>
<li>对该共享数据结构的操作定义为一组过程, 通过调用这些过程实现对共享资源的申请, 释放和其他操作</li>
</ul>
<p>管程的组成 = 局部数据 + 过程 + 初始化序列</p>
<p>管程的特点</p>
<ol>
<li>局部数据变量只能被管程的过程访问, 任何外部过程都不能访问</li>
<li>一个进程通过调用管程的一个过程进入管程</li>
<li>任何时候, 只能有一个进程在管程中执行, 调用管程的任何其他进程都被阻塞</li>
</ol>
<p>若一个正在管程中执行的进程必须阻塞, 可以释放管程供其他进程使用</p>
<p>如果管程内的数据结构代表了共享资源, 则通过管程提供了对资源的互斥访问机制</p>
<h4 id="用管程实现进程同步">用管程实现进程同步</h4>
<p>管程通过使用条件变量提供对进程同步的支持</p>
<p>条件变量包含在管程中, 只能在管程中访问</p>
<p>操作条件变量的两个函数</p>
<ul>
<li>cwait©, 在条件c上阻塞进程, 管程可供其他进程使用</li>
<li>csignal©, 恢复在条件c上阻塞的进程, 若不存在阻塞进程, 则不操作</li>
<li>这里cwait和csignal作用于条件变量, 与作用于信号量的wait和signal不同</li>
</ul>
<h3 id="消息传递">消息传递</h3>
<p>进程交互时, 需要满足两个基本要求</p>
<ul>
<li>同步: 为实现互斥, 进程间需要同步</li>
<li>通信: 为实现合作, 进程间需要交换信息</li>
</ul>
<p>消息传递提供了上述两方面功能</p>
<h4 id="通信原语">通信原语</h4>
<p>Send(destination, message)</p>
<p>Receive(source, message)</p>
<p>进程给指定的进程发消息, 进程通过接收原语receive接收消息, 接收原语中指明源进程和消息</p>
<h4 id="消息格式">消息格式</h4>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231224124716821.png" alt="image-20231224124716821"></p>
<h4 id="消息传递问题中的同步">消息传递问题中的同步</h4>
<p>只有发送进程发送消息, 接收进程才能收到消息</p>
<p>发送进程调用发送原语时</p>
<ul>
<li>发送进程发送消息后, 要么阻塞直到这个消息被目标进程收到</li>
<li>要么不阻塞</li>
</ul>
<p>一个进程调用接收原语时</p>
<ul>
<li>若没有消息到达, 接收者要么阻塞等待, 要么放弃接收, 继续执行</li>
<li>若已经有消息到达, 则接收者接收消息并继续执行</li>
</ul>
<h4 id="消息的寻址方式">消息的寻址方式</h4>
<p>send和receive原语确定目标和原进程的方式有两类</p>
<ul>
<li>直接寻址</li>
<li>间接寻址</li>
</ul>
<h5 id="直接寻址">直接寻址</h5>
<p>Send原语包含目标进程的标识号</p>
<p>Receive原语有两种处理方式</p>
<ul>
<li>显示的指明源进程: 对于处理并发进程的合作有效</li>
<li>不可能指定源进程: 如就打印机服务进程, 采用隐式寻址, 接收到消息时将源地址保存下来</li>
</ul>
<h5 id="间接寻址">间接寻址</h5>
<ol>
<li>消息被发送到一个共享的数据结构, 该结构由暂存消息的队列构成</li>
<li>队列也被称为信箱</li>
<li>发送进程往信箱发送消息, 接收进程从信箱取走消息</li>
<li>提供了对消息使用的灵活性</li>
</ol>
<p>简介寻址发送者和接收者之间的关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231224130035604.png" alt="image-20231224130035604"></p>
<h5 id="使用消息传递实现互斥">使用消息传递实现互斥</h5>
<p>多个并发执行的发送进程和接受进程共享一个邮箱box, box初始状态仅包含一条&quot;空消息&quot;(好比进入临界区的令牌)</p>
<p>不阻塞发送, 阻塞接收</p>
<p>若邮箱中存在一条消息, 则允许一个进程进入临界区</p>
<p>若邮箱为空, 表明有一个进程位于临界区, 其他试图进入临界区的进程必须阻塞</p>
<p>只要保证邮箱中最多只有一条消息, 就能保证只允许一个进程进入临界区, 从而实现进程互斥使用临界资源</p>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231224132331165.png" alt="image-20231224132331165" style="zoom:67%;" />
<h4 id="使用消息传递实现生产者-消费者问题">使用消息传递实现生产者/消费者问题</h4>
<p>使用两个邮箱mayconsume和mayproduce, 大小均为capacity</p>
<p>Mayproduce</p>
<ul>
<li>起初填满空消息(即允许生产的令牌)</li>
<li>该邮箱有消息, 生产者就可以生产</li>
<li>每次生产前取一条空消息, 之后生产数据, 并将数据作为消息发至mayconsume邮箱</li>
<li>消费者的每次消费使得该邮箱中的空消息数增加</li>
</ul>
<p>Mayconsume</p>
<ul>
<li>生产者产生的数据作为消息发送到该信箱(即允许消费的令牌)</li>
<li>只要该邮箱有数据消息, 消费者就可以消费</li>
<li>每次消费前, 取一条消息, 消费后, 向mayproduce发送一条空消息</li>
<li>生产者的每次生产使得该邮箱的消息数增加</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231224132759516.png" alt="image-20231224132759516" style="zoom:80%;" />
<h2 id="第二章-进程管理4-死锁">第二章 进程管理4–死锁</h2>
<h3 id="死锁的原理">死锁的原理</h3>
<p>进程死锁现象: 进程P和Q共享资源</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231224173155378.png" alt="image-20231224173155378"></p>
<p>死锁: 一组相互竞争系统资源或进行通信的进程间的永久阻塞</p>
<p>当一组进程中的每个进程都在等待某事件, 而只有同组进程中阻塞的其他进程能够促发该事件时, 死锁发生</p>
<p>死锁是永久性的, 没有有效的解决方案</p>
<p>资源的分类</p>
<ul>
<li>
<p>可重用资源</p>
<p>依次仅供一个进程使用且不因使用而耗尽的资源</p>
<p>如处理器, I/O通道, 内存和外存, 设备</p>
</li>
<li>
<p>可消耗资源</p>
<p>可消耗资源是指可被创建(生产)和销毁(消耗)的资源</p>
<p>如中断, 信号, 信息和I/O缓冲中的信息</p>
</li>
</ul>
<p>竞争可重用资源, 可消耗资源都可能引起死锁</p>
<p>下面的资源分配图中, 存在环就存在死锁</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231224175922285.png" alt="image-20231224175922285"></p>
<h4 id="死锁的条件">死锁的条件</h4>
<ul>
<li>
<p>充分条件</p>
<p>循环等待, 存在一闭合的进程链</p>
</li>
<li>
<p>必要条件</p>
<ol>
<li>互斥, 同一时刻只有一个进程可以使用一个资源</li>
<li>占用且等待, 进程等待其他资源时, 继续占有已经分配的资源</li>
<li>不可抢占, 不能强行抢占进程已经占有的资源</li>
</ol>
</li>
</ul>
<h4 id="死锁的解决">死锁的解决</h4>
<ol>
<li>
<p>死锁预防</p>
<p>防止死锁产生条件的发生</p>
</li>
<li>
<p>死锁避免</p>
<p>允许三个必要条件, 根据当前资源分配状态来做出资源分配决策, 保证不产生死锁</p>
</li>
<li>
<p>死锁检测与解除</p>
<p>不限制资源访问或约束进程行为, 而是检测死锁的存在并尝试解除</p>
</li>
</ol>
<h3 id="死锁预防">死锁预防</h3>
<p>两类方法</p>
<ul>
<li>间接方法: 防止三个必要条件中的任意一个条件发生
<ul>
<li>互斥: 互斥不能禁止</li>
<li>防止占有且等待: 要求进程一次性请求所有资源, 阻塞进程直至所有资源能满足, 但有低效和事先不知道进程所需全部资源的问题</li>
<li>防止不可抢占: 一个占有某些资源的进程进一步申请资源时若被拒绝, 则释放最初占有的资源; 或OS要求另一个进程释放资源. 只有在资源状态容易保存和恢复的情况下才实用</li>
</ul>
</li>
<li>直接方法: 防止循环等待的发生
<ul>
<li>定义请求资源的顺序, 把资源按类型进行线性排队, 所有进程对资源的请求必须严格按资源序号递增顺序提出. 这种方法低效</li>
</ul>
</li>
</ul>
<h3 id="死锁避免">死锁避免</h3>
<p>允许三个必要条件</p>
<p>动态检查</p>
<ul>
<li>在系统运行过程中, 检查进程的资源申请, 根据检查结果决定是否分配资源
<ul>
<li>若分配后系统可能死锁, 则不予分配, 阻塞进程</li>
<li>否则予以分配</li>
</ul>
</li>
<li>需要预知资源的请求</li>
</ul>
<h4 id="死锁避免的两种方法">死锁避免的两种方法</h4>
<ul>
<li>资源分配拒绝</li>
<li>进程启动拒绝</li>
</ul>
<h5 id="进程启动拒绝">进程启动拒绝</h5>
<p>若一个进程请求会导致死锁, 则不启动该进程</p>
<h5 id="资源分配拒绝-又称银行家算法">资源分配拒绝, 又称银行家算法</h5>
<p>若一个进程增加的资源请求会导致死锁, 则不会允许这一资源分配</p>
<p>系统的状态反映出当前给进程分配资源的情况</p>
<p>安全状态指至少有一个资源分配序列(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>P</mi><mi>y</mi></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>P</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">P_x, P_y, \cdots, P_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 安全序列)不会导致死锁, 所有进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>P</mi><mi>y</mi></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>P</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">P_x, P_y, \cdots, P_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>能够运行结束</p>
<h6 id="安全状态与不安全状态的思考">安全状态与不安全状态的思考</h6>
<p>安全序列是否唯一? 不是</p>
<p>安全状态是否一定没有死锁发生? 若系统处于安全状态, 且按照某个安全序列分配资源, 则不会出现死锁</p>
<p>并非所有不安全状态都是死锁状态(若某一进程提前释放了资源, 让其他进程可以使用资源, 后来再次需要这些资源, 系统就变成了安全状态)</p>
<p>当系统进入不安全状态后, 便可能进入死锁状态</p>
<p>避免死锁的实质在于: 如何避免系统进入不安全系统</p>
<h4 id="死锁避免的优点">死锁避免的优点</h4>
<ul>
<li>无须死锁预防中的抢占和回滚(释放最初占有的资源)</li>
<li>比起死锁预防, 限制少</li>
</ul>
<h4 id="死锁避免的使用限制">死锁避免的使用限制</h4>
<ul>
<li>必须事先声明每个进程请求的最大资源</li>
<li>进程必须是独立的, 它们执行顺序没有同步的要求</li>
<li>分配资源的数量必须是固定的</li>
<li>占有资源时, 进程不能退出</li>
</ul>
<h3 id="死锁检测与解除">死锁检测与解除</h3>
<h4 id="死锁检测">死锁检测</h4>
<p>对死锁的检测可以频繁的发生在每次资源请求时, 也可以少检测, 具体取决于死锁发生的可能性</p>
<p>优缺点</p>
<ul>
<li>
<p>优点</p>
<ol>
<li>可尽早检测死锁</li>
<li>算法相对简单</li>
</ol>
</li>
<li>
<p>缺点</p>
<p>频繁的检测会耗费处理器相当多的时间</p>
</li>
</ul>
<h5 id="死锁检测算法步骤">死锁检测算法步骤</h5>
<ol>
<li>标记Allocation矩阵中一行全为零的进程</li>
<li>初始化一个向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>, 令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>等于Available向量</li>
<li>查找下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>, 进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>当前未标记且满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Q_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>请求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>类资源的数量)的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>行小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>, 即对所有的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi><mo separator="true">,</mo><msub><mi>Q</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>≤</mo><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">1\leq k\leq m, Q_{ik}\leq W_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 若找不到这样的行, 终止算法</li>
<li>若找到这样的行, 标记进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>, 并把Allocation矩阵中的响应行加到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>中, 即对所有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq k\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>, 令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub><mo>=</mo><msub><mi>W</mi><mi>k</mi></msub><mo>+</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_k = W_k + A_{ik}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 返回3</li>
</ol>
<p>当且仅当最终有未标记进程时, 才存在死锁, 未标记的进程都是死锁的</p>
<h5 id="资源分配图进行死锁检测">资源分配图进行死锁检测</h5>
<p>资源分配图的化简:</p>
<ol>
<li>在图中找到全部请求都能满足的进程节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 消去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所有的请求边和分配边, 使之成为孤立的节点</li>
<li>重复步骤1, 直至无法化简为止</li>
</ol>
<p>示例</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225103828601.png" alt="image-20231225103828601"></p>
<p>可完全化简图</p>
<ul>
<li>能消去图中所有的边, 使所有进程节点都成为孤立结点的资源分配图</li>
<li>不可完全化简图存在死锁</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225104050865.png" alt="image-20231225104050865"></p>
<h4 id="死锁解除">死锁解除</h4>
<p>检测死锁后, 按照某种可能的策略来解除</p>
<ol>
<li>
<p>撤销进程</p>
<p>撤销死锁进程直至不再存在死锁</p>
</li>
<li>
<p>回退</p>
<p>把进程回退到前面定义的某些检查点, 并重新启动所有进程</p>
</li>
<li>
<p>抢占</p>
<p>连续抢占资源直至不再存在死锁</p>
</li>
</ol>
<p>取消/抢占哪些进程的资源?选择原则:</p>
<ul>
<li>消耗处理器时间少, 或输出少, 或分配资源少, 或剩余时间长, 或优先级最低的进程</li>
</ul>
<h3 id="哲学家就餐问题">哲学家就餐问题</h3>
<p>描述: 5个哲学家围坐一张餐桌, 5只餐叉间隔摆放, 哲学家不是思考就是在进餐, 进餐时必须同时拿到两边的餐叉, 思考时将餐叉放回原处</p>
<h4 id="资源分级方法一">资源分级方法一</h4>
<ul>
<li>为餐叉编号</li>
<li>就餐前, 先取编号较低的餐叉, 再取编号较高的餐叉</li>
<li>就餐完, 先放下编号较高的餐叉, 再放下编号较低的餐叉(也可不限制)</li>
</ul>
<h4 id="资源分级方法二">资源分级方法二</h4>
<ul>
<li>为哲学家编号</li>
<li>奇数号的哲学家必须先拿左边的餐叉</li>
<li>偶数号的哲学家必须先拿右边的餐叉</li>
</ul>
<h4 id="服务生方法">服务生方法</h4>
<p>引入一个餐厅服务生, 哲学家必须经过他的允许才能拿起餐叉, 最多允许4个哲学家同时进食</p>
<h4 id="哲学家就餐问题的引申-and型信号量集">哲学家就餐问题的引申: And型信号量集</h4>
<p>在一个原语中申请需要的多个临界资源, 要么全部分, 要么一个都不分配</p>
<p>AND型信号量集P原语为Swait(S1, S2, …, Sn), V原语为Ssignal(S1, S2, …, Sn)</p>
<h4 id="管程解决方案">管程解决方案</h4>
<h2 id="内存管理1-基本">内存管理1–基本</h2>
<p>内存管理: 关注内存和外存之间的信息流的组织</p>
<h3 id="程序的加载">程序的加载</h3>
<p>高级语言源代码转化为进程的3个步骤</p>
<ol>
<li>
<p>编译</p>
<p>编译程序将源代码编译为若干个目标模块</p>
</li>
<li>
<p>链接</p>
<p>链接程序将模块和他们所需要的库函数链接在一起, 形成一个完整的加载模块</p>
</li>
<li>
<p>加载(装入)</p>
<p>由加载程序将加载模块装入内存</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225111922217.png" alt="image-20231225111922217"></p>
<p>加载的任务</p>
<ul>
<li>
<p>将可加载模块装入内存</p>
</li>
<li>
<p>地址重定位</p>
<p>将执行文件中的逻辑地址转化为内存物理地址的过程</p>
</li>
</ul>
<p>加载方式分类(地址映射建立方式)</p>
<ul>
<li>绝对加载方式</li>
<li>可重定位加载(静态重定位)方式</li>
<li>运行时加载(动态重定位)方式</li>
</ul>
<h4 id="绝对加载方式">绝对加载方式</h4>
<p>程序中的逻辑地址与实际内存地址完全相同, 不需对程序和数据的地址修改</p>
<p>编译程序产生绝对地址的目标代码, 编译时就知道程序将驻留在内存中的具体位置</p>
<p>为了便于程序的修改, 对程序采用符号地址, 在编译时转化为绝对地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225112522957.png" alt="image-20231225112522957"></p>
<p>优缺点</p>
<ul>
<li>
<p>优点</p>
<p>实现简单, 无须逻辑地址到物理地址的变换</p>
</li>
<li>
<p>缺点</p>
<ol>
<li>程序每次必须装入同一内存区</li>
<li>程序员必须实现了解内存的使用情况, 根据内存情况确定程序的逻辑地址</li>
<li>不适用于多道程序系统</li>
</ol>
</li>
</ul>
<h4 id="可重定位加载方式-静态重定位">可重定位加载方式(静态重定位)</h4>
<p>编译时采用相对地址, 即编译器假设是加载到从零开始的内存位置</p>
<p>逻辑地址与装入内存后的物理地址无直接关系</p>
<p>必须进行重定位, 即加载程序根据加载的位置将逻辑地址转换为物理地址</p>
<p>静态重定位技术: 地址映射在程序加载时进行, 以后不再更改程序地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225140007689.png" alt="image-20231225140007689"></p>
<p>优缺点:</p>
<ul>
<li>优点: 易实现, 无需硬件支持</li>
<li>缺点: 程序重定位后就不能移动, 因而不能重新分配内存, 不利于内存的有效利用</li>
</ul>
<h4 id="运行时加载-动态重定位-方式">运行时加载(动态重定位)方式</h4>
<p>程序地址转换在程序运行时动态进行</p>
<p>运行时动态加载需要硬件支持, 即重定位寄存器, 用于保存程序在内存中的起始地址</p>
<p>程序被执行时, 通过重定位寄存器内的起始物理地址和指令或数据的逻辑地址计算其物理地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225154226563.png" alt="image-20231225154226563"></p>
<p>优缺点</p>
<ul>
<li>优点
<ol>
<li>程序不必连续存放在内存中, 可分散存储, 可移动</li>
<li>便于共享</li>
<li>有利于紧凑, 碎片问题的解决</li>
<li>主流方式</li>
</ol>
</li>
<li>缺点
<ol>
<li>需要硬件支持, 实现存储管理的软件算法比较复杂</li>
<li>同一地址, 可能多次转换</li>
</ol>
</li>
</ul>
<h4 id="程序加载方法小结">程序加载方法小结</h4>
<ul>
<li>
<p>绝对加载</p>
<p>编译时执行: 编译时就知道进程将在内存中的驻留地址, 生成绝对代码. 在可执行文件中记录内存地址, 加载时直接定位在该内存地址</p>
<p>如果将来开始地址发生变化, 就必须重新编译代码</p>
</li>
<li>
<p>静态重定位加载</p>
<p>加载时执行, 静态地址重定位: 地址绑定在加载内存时才进行. 系统根据内存当时的使用情况, 决定将目标代码放在内存的什么位置</p>
<p>不允许程序在内存中移动</p>
</li>
<li>
<p>不允许程序在内存中移动</p>
<p>执行时执行, 动态地址重定位: 地址绑定延迟到执行时才进行</p>
<p>支持执行时进程在内存中移动</p>
</li>
</ul>
<h3 id="程序的链接">程序的链接</h3>
<p>链接</p>
<ul>
<li>源程序经过编译后, 可得到一组目标模块</li>
<li>链接程序将这组目标模块链接, 产生一个包含完整程序和数据模块的加载模块</li>
</ul>
<p>链接方式(链接的时机)</p>
<ul>
<li>静态链接</li>
<li>加载时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h4 id="静态链接">静态链接</h4>
<p>程序运行前, 先将各目标模块及它们所需的库函数, 链接成一个完整的装配模块, 以后不再拆开</p>
<p>静态链接需要解决两个问题</p>
<ol>
<li>
<p>相对地址的修改</p>
<p>由编译程序产生的所有目标模块中, 使用的都是相对地址, 链接成一个加载模块时需要修改模块的相对地址</p>
</li>
<li>
<p>变换外部引用地址</p>
<p>每个模块中所用的外部调用符号也都变换为相对地址</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225155345786.png" alt="image-20231225155345786"></p>
<p>缺点</p>
<ul>
<li>不利于代码共享(每个应用都含有目标模块的拷贝)</li>
<li>不利于模块的独立升级(每次对某个目标模块的修改升级, 都要打开整个加载模块)</li>
<li>可能链接一些不会执行的模块, 浪费存储空间和处理机时间</li>
</ul>
<h4 id="加载时动态链接">加载时动态链接</h4>
<p>在加载内存时, 如果待加载的模块中有到外部模块的引用, 加载程序将查找这些模块并加载内存, 并把这些引用修改为相对应用程序模块开始处的相对地址</p>
<p>优缺点</p>
<ul>
<li>优点
<ol>
<li>便于各个模块的独立升级</li>
<li>便于实现模块的共享</li>
</ol>
</li>
<li>缺点
<ol>
<li>可能链接一些不会执行的模块, 浪费存储时间和处理机时间</li>
<li>模块加载后不能移动位置</li>
</ol>
</li>
</ul>
<h4 id="运行时动态链接">运行时动态链接</h4>
<p>程序执行中需要某目标模块时, 由OS找到模块并将之加载内存, 随后把它链接到调用者模块上</p>
<p>优点</p>
<ol>
<li>凡是在执行过程中未用到的目标模块, 不会被调入内存和被链接到加载模块上, 加快了程序的加载过程, 节省了大量的内存空间</li>
<li>支持分段系统</li>
</ol>
<h3 id="内存管理的需求">内存管理的需求</h3>
<ol>
<li>重定位</li>
<li>保护</li>
<li>共享</li>
<li>逻辑组织</li>
<li>物理组织</li>
</ol>
<h4 id="重定位">重定位</h4>
<p>为什么要有重定位?</p>
<ol>
<li>程序员事先不知道在某个程序执行期间会有其他哪些程序驻留在内存中</li>
<li>把活动进程换入或换出内存, 进而使处理器的利用率最大化</li>
<li>进程下次换入时若要放在相同区域, 会存在诸多困难</li>
</ol>
<p>重定位–进程寻址的需求</p>
<ol>
<li>OS需要知道进程控制信息, 栈和入口点位置</li>
<li>处理器需要处理程序内部的内存访问, 处理跳转指令和数据访问指令的地址转换</li>
</ol>
<h4 id="保护">保护</h4>
<ol>
<li>进程以外的其他进程中的程序不能未经授权地访问(读或写)进程的内存单元</li>
<li>程序在内存中的位置不可预测</li>
<li>需要支持重定位和保护的机制, 处理器硬件需要有这个能力</li>
</ol>
<h4 id="共享">共享</h4>
<ol>
<li>多个进程正在执行同一程序时, 允许每个进程访问该程序的同一个副本, 这比每个进程有独立副本要有利</li>
<li>需要支持重定位和共享的机制</li>
</ol>
<h4 id="逻辑组织">逻辑组织</h4>
<p>内存被组织称线性(或一维)地址空间</p>
<p>分段可以满足该需求</p>
<p>为什么程序按模块组织?</p>
<ol>
<li>可以独立编写和编译模块</li>
<li>可以为不同的模块提供不同的保护级别(只读, 只执行)</li>
<li>模块可以被多个进程共享, 与用户看待问题的方式一致</li>
</ol>
<h4 id="物理组织">物理组织</h4>
<p>在内存和外存间完成移动信息的任务应该交给OS而不是程序员, 因为</p>
<ol>
<li>不应让程序员负责管理内存</li>
<li>可供程序和数据使用的内存可能不足</li>
<li>程序员不知道可用空间的大小和位置</li>
<li>覆盖允许不同的模块占用相同的存储空间, 但是编程耗时</li>
</ol>
<h3 id="内存分区">内存分区</h3>
<p>内存管理的主要操作是处理器把程序加载到内存中执行</p>
<p>内存管理包括虚拟内存的复杂方案</p>
<p>内存分区有基于分段和分页的两种基本技术</p>
<h4 id="固定分区">固定分区</h4>
<p>分区数量固定</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
<h5 id="分区大小相等">分区大小相等</h5>
<p>存在问题</p>
<ul>
<li>程序可能太大而不能放到一个分区中</li>
<li>内存的利用率非常低, 会产生很多内部碎片</li>
</ul>
<h5 id="分区大小不等">分区大小不等</h5>
<p>可以使内部碎片更小</p>
<p>固定分区的问题</p>
<ol>
<li>分区数量在系统生成阶段已经确定, 限制了系统活动进程的数量</li>
<li>小作业不能有效地利用分区空间</li>
</ol>
<h4 id="动态分区">动态分区</h4>
<p>分区大小和数量不固定</p>
<p>分配与进程需求完全一致的闲散内存空间</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225165341486.png" alt="image-20231225165341486"></p>
<p>外部碎片</p>
<ul>
<li>动态分区方法在内存中产生越来越多的碎片</li>
<li>内存利用率下降</li>
</ul>
<p>压缩(紧凑)</p>
<ul>
<li>解决外部碎片问题的技术</li>
<li>OS移动进程, 使进程占用的空间连续</li>
<li>所有空闲空间连成一片</li>
<li>紧凑费时, 浪费处理器时间</li>
</ul>
<p>动态分区分配算法</p>
<ol>
<li>首次匹配</li>
<li>下次匹配(循环匹配)</li>
<li>最佳匹配</li>
<li>最差匹配</li>
</ol>
<h5 id="首次匹配">首次匹配</h5>
<p>从头扫描内存, 选择第一个可用块</p>
<p>要求空闲分区以地址递增的顺序链接, 从链首开始查找</p>
<p>评价</p>
<ol>
<li>简单, 快速</li>
<li>为大作业分配大的内存空间创造条件</li>
<li>内存前段出现很多小的空闲分区, 每次查找都要经过这些分区</li>
</ol>
<h5 id="循环匹配-下次匹配">循环匹配/下次匹配</h5>
<p>从上一次放置的位置开始扫描内存, 选择下一个大小足够的可用块</p>
<p>空闲分区按地址从低到高排列</p>
<p>评价</p>
<ol>
<li>比首次匹配性能差, 常常在内存末尾分配空间, 导致空闲的分区分布均匀</li>
<li>缺少大的空闲块, 需要更多次数紧凑</li>
</ol>
<h5 id="最佳匹配">最佳匹配</h5>
<p>选择空间大小与需求最接近的空闲块分配</p>
<p>空闲分区按容量大小从小到大链接</p>
<p>评价</p>
<ol>
<li>产生的外部碎片很小</li>
<li>内存中形成很多小到无法满足任何分配需求的块</li>
<li>需要频繁进行内存压缩</li>
</ol>
<h5 id="最差匹配">最差匹配</h5>
<p>选择满足需求的最大空闲分区分配</p>
<p>空闲分区按容量从大到小链接</p>
<p>评价</p>
<ol>
<li>每次分配留下的空闲空间较大, 便于再次利用</li>
<li>大的空间不容易保留, 对大作业不利</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225170145110.png" alt="image-20231225170145110"></p>
<h4 id="伙伴系统">伙伴系统</h4>
<p>固定分区方案限制了活跃进程的数量. 如果分区大小与进程大小不匹配, 内存空间的利用率很低</p>
<p>动态分区方案维护复杂, 引入了压缩的额外开销</p>
<p>折中方案: 伙伴系统</p>
<p>分配的空间可以视为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span>的块, 每次分配的块的大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>≤</mo><mi>K</mi><mo>≤</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">L\leq K\leq U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>, 且</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">2^L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span></span></span></span> = 分配的最小块的大小</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> = 分配的最大块的大小</li>
<li>通常, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span>是内存中整个可分配空间的大小</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225171616135.png" alt="image-20231225171616135"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225171624143.png" alt="image-20231225171624143"></p>
<p>评价:</p>
<ol>
<li>较为合理的折中方案, 一定程度上克服了固定分区和动态分区的缺陷</li>
<li>是并行程序分配和释放的一种有效方案</li>
<li>UNIX内核存储分配中使用了一种改进的伙伴系统</li>
</ol>
<h4 id="重定位">重定位</h4>
<p>地址类型</p>
<ul>
<li>逻辑地址: 与当前数据在内存中的物理分配无关的访问地址, 执行前要转换成物理地址</li>
<li>相对地址: 逻辑地址的特例, 相对于某些已知点的存储单元</li>
<li>物理地址: 内存中的实际地址</li>
</ul>
<p>重定位的硬件支持</p>
<ul>
<li>基地址寄存器: 存放作业的起始地址</li>
<li>界限寄存器: 存放作业界限地址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225171902347.png" alt="image-20231225171902347"></p>
<h3 id="分页">分页</h3>
<p>将内存划分成大小固定且相等的块, 且块相对较小. 进程也划分成同样大小的块</p>
<p>页: 进程中的块</p>
<p>页框: 内存中的块</p>
<p>将进程的页装入内存的页框</p>
<p>分页的逻辑地址 = 页号 + 页内偏移量. 下面是32位机, 4KB/页的分页存储系统逻辑地址结构示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225190536397.png" alt="image-20231225190536397"></p>
<h4 id="页表">页表</h4>
<ul>
<li>OS为每个进程维护一个页表</li>
<li>页表包括进程中每个页对应的页框位置</li>
<li>处理器需要知道如何访问当前进程的页表</li>
<li>处理器使用页表来生成一个物理地址</li>
</ul>
<p>页表的存储</p>
<ul>
<li>页表存放在内存</li>
<li>PCB保存有页表的起始地址</li>
<li>页表寄存器存放当前运行进程的页表的起始地址</li>
</ul>
<h4 id="页号和页内地址的计算">页号和页内地址的计算</h4>
<p>对于某特定机器, 其地址结构是一定的. 若给定一个逻辑地址空间中的地址为A, 页面的大小为L, 则页号P和页内地址d可按下式:</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225190904470.png" alt="image-20231225190904470"></p>
<p>示例:</p>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225190955266.png" alt="image-20231225190955266" style="zoom: 67%;" />
<h4 id="分页的逻辑地址到物理地址的转换">分页的逻辑地址到物理地址的转换</h4>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225194805803.png" alt="image-20231225194805803"></p>
<h4 id="分页存储管理的优缺点">分页存储管理的优缺点</h4>
<ul>
<li>优点
<ol>
<li>存在页内碎片, 但碎片相对较小, 内存利用率高</li>
<li>实现了离散分配</li>
<li>无外部碎片</li>
</ol>
</li>
<li>缺点
<ol>
<li>需要专门的硬件支持, 尤其是快表</li>
<li>不支持动态链接, 不易实现共享</li>
</ol>
</li>
</ul>
<h3 id="分段">分段</h3>
<p>一个程序可以划分成几个段, 段的长度可以不等, 每个段从0开始编址, 并占用一段连续的地址空间爱你, 有最大段长限制</p>
<p>分段类似动态分区, 分段使一个程序可以占据多个分区, 且不必联系, 消除了内部碎片</p>
<p>分页对用户透明, 分段对用户可见</p>
<p>分段是一种组织程序和数据更方便的手段, 程序员或编译器将程序和数据划分到不同的段. 为实现模块化程序设计, 程序和数据可能会进一步被划分成多个段</p>
<p>不便: 程序员或编译器需要清楚最大段长限制</p>
<p>逻辑地址 = 段号 + 段内偏移量</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225201802024.png" alt="image-20231225201802024"></p>
<h4 id="段表">段表</h4>
<p>段表: 记录逻辑段和物理段的对应情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225201854809.png" alt="image-20231225201854809"></p>
<p>逻辑地址与物理地址的转换:</p>
<ol>
<li>提取段号: 逻辑地址最左侧的n位</li>
<li>以段号为索引, 查找段表中该段的起始物理地址</li>
<li>逻辑地址最右侧m位为偏移量, 偏移量与段长度比较, 若偏移量&gt;段长, 则地址无效</li>
<li>物理地址: 该段的起始物理地址 + 偏移量</li>
</ol>
<h4 id="分段逻辑地址转换为物理地址示例">分段逻辑地址转换为物理地址示例</h4>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225202236238.png" alt="image-20231225202236238"></p>
<h4 id="分段存储管理的优点和缺点">分段存储管理的优点和缺点</h4>
<ul>
<li>优点
<ol>
<li>便于程序模块化设计</li>
<li>便于动态链接</li>
<li>便于保护和共享</li>
<li>无内部碎片</li>
</ol>
</li>
<li>缺点
<ol>
<li>地址转换需要硬件的支持–段表寄存器</li>
<li>分段的最大尺寸收到主存可用空间的限制</li>
<li>有外部碎片</li>
</ol>
</li>
</ul>
<h4 id="分页和分段的比较">分页和分段的比较</h4>
<ol>
<li>页是信息的物理单位, 分页的目的是实现离散分配, 减少内存的外部碎片, 提高内存利用率. 分页是系统管理的需要而不是用户的需要. 段是信息的逻辑单位, 它含有一组意义相对完整的信息, 分段的目的是为了满足用户的需要</li>
<li>页的大小固定且由系统决定, 系统把逻辑地址划分为页号和页内地址两部分, 是由机器硬件实现的, 所以在系统中只能有一种大小的页面. 段的长度不固定, 决定于用户编写的程序, 通常由编译程序在对源程序进行编译时, 根据信息的性质来划分</li>
<li>分页的作业地址空间是一维的, 即一个记忆符可以表示一个地址. 分段的作业地址空间是二维的, 段名和段内地址共同标识一个地址</li>
<li>分页存储管理系统不易实现&quot;共享&quot;, 不支持&quot;运行时动态链接&quot;. 分段存储管理系统易于实现&quot;共享&quot;和&quot;动态链接&quot;</li>
</ol>
<h2 id="第三章-内存管理2-虚拟内存管理">第三章 内存管理2–虚拟内存管理</h2>
<p>虚拟内存的支持条件</p>
<ul>
<li>分页或分段的硬件支持</li>
<li>操作系统必须有管理页或段在内存和辅存间移动的软件</li>
</ul>
<h3 id="虚拟内存术语">虚拟内存术语</h3>
<ul>
<li>虚拟内存: 辅存可被看作主存的一部分来完成寻址. 程序使用的地址与内存物理存储的地址不同, 程序生成的地址会自动转换为物理地址. 虚拟存储的大小受计算机系统寻址机制和可用辅存容量的限制, 而不受主存实际大小限制</li>
<li>虚拟地址/逻辑地址: 在虚拟内存中分配给某一位置的地址, 使得该位置可被访问.</li>
<li>虚拟地址空间: 分配给进程的虚拟存储</li>
<li>地址空间爱你: 用于某进程的内存地址范围</li>
<li>实地址: 内存中存储位置的地址</li>
</ul>
<h3 id="硬件和控制结构">硬件和控制结构</h3>
<p>分页和分段内存管理的两个基本特征</p>
<ul>
<li>进程中所有内存访问都是逻辑地址, 逻辑地址会动态地转换为物理地址</li>
<li>一个进程可划分为许多块(页和段), 在执行过程中, 这些块不需要连续地位于内存中</li>
</ul>
<p>若上述特征存在, 则在一个进程执行过程中, 该进程不需要所有页或所有段都在内存中</p>
<p>进程的执行过程:</p>
<ol>
<li>OS仅读取包含程序开始处的几个块进入内存</li>
<li>任意时刻, 进程驻留在内存的部分–驻留集</li>
<li>访问一个不在内存中的逻辑地址(称为内存失效), 产生一个中断</li>
<li>OS把被中断的进程置为阻塞状态</li>
<li>OS把该进程中包含引发内存失效的部分读入内存
<ul>
<li>OS产生一个磁盘I/O读请求</li>
<li>在执行磁盘I/O期间, OS调度另外一个进程运行</li>
<li>磁盘I/O完成后产生中断, OS将相应的进程置于就绪状态</li>
</ul>
</li>
</ol>
<p>提高系统利用率的方法:</p>
<ol>
<li>内存中保留多个进程
<ul>
<li>每个进程仅装入部分块</li>
<li>任何时刻内存中的进程至少有一个处于就绪状态</li>
<li>提高了处理器的利用率</li>
</ul>
</li>
<li>进程可以比内存的全部空间还大
<ul>
<li>基于分页和分段的技术, OS和硬件只加载程序的一部分</li>
<li>程序员面对的是一个巨大内存, 大小与磁盘存储器相关</li>
</ul>
</li>
</ol>
<p>实存储器(实存) – 主存, 实际的物理内存</p>
<p>虚拟内存(虚存) – 感觉更大的内存, 且常分配在磁盘上; 更有效地支持并发, 减轻用户对内存的严格限制</p>
<p>使用和不适用虚存技术下分页或分段的特点</p>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225212912650.png" alt="image-20231225212912650" style="zoom:67%;" />
<h4 id="局部性和虚拟内存">局部性和虚拟内存</h4>
<p>抖动: 即将要用到的块被换出, 系统又得很快将它取回, 导致页面被频繁地换入换出, 缺页率急剧增加</p>
<p>内存空间几乎被进程快占据时, 如果出现抖动, 则处理器的大部分时间都用于交换而非执行指令. 为了避免这种情况, OS根据最近的历史来猜测将来最可能用到的块</p>
<p>局部性原理:</p>
<ul>
<li>存储器的访问呈簇性(簇: 一组程序或数据的集合), 在很长一段时间内, 使用的簇会发生变化; 在很短的时间内, 处理器与固定的簇接触)</li>
<li>局部性原理描述了程序和数据引用的集簇倾向, 在很短时间内进需要一部分块, 对将来访问的块可以猜测, 避免抖动</li>
<li>局部性原理说明虚存方案是可行的</li>
</ul>
<h4 id="分页">分页</h4>
<p>虚拟内存常与分页系统联系在一起</p>
<p>收个使用分页实现虚拟存储的Atlas计算机</p>
<p>每个进程都有自己的页表</p>
<ul>
<li>分页的虚存方案中, 页表项变得更复杂</li>
</ul>
<h5 id="页表项">页表项</h5>
<p>存在位P: 表明对应的页是否在内存</p>
<p>页框号: 若页在内存, 则有对应的页框号</p>
<p>修改位M: 表明相应页上次装入内存到现在是否修改过</p>
<ul>
<li>若修改过, 换出时要更新辅存上对应页</li>
<li>若没有若改过, 换出时不必更新</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225222433977.png" alt="image-20231225222433977"></p>
<h5 id="分页系统中的地址转换">分页系统中的地址转换</h5>
<ul>
<li>页表位于内存</li>
<li>进程运行时, 一个寄存器保存页表的起始地址</li>
<li>虚拟地址的页号用于检索页表, 查找对应页框号</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225223121036.png" alt="image-20231225223121036"></p>
<h5 id="庞大的页表组织">庞大的页表组织</h5>
<p>每个进程一个页表, 如果进程的逻辑地址空间大, 则页表庞大</p>
<p>大多数虚拟内存在虚存而非内存中保存页表</p>
<ul>
<li>分页和其他页一样服从分页管理</li>
<li>进程运行时, 它的页表至少一部分在内存, 这部分包含正在运行页的页表项</li>
</ul>
<p>庞大页表的离散存储解决方案 – 多级页表</p>
<h5 id="两级页表">两级页表</h5>
<ul>
<li>页表分页, 典型情况喜爱每页大小最大限制和进程分页大小一致</li>
<li>建立页目录, 每项指向一页页表</li>
<li>页目录长度X, 页表项数Y, 则一个进程可以有XY页</li>
</ul>
<h6 id="32位地址的两级页表">32位地址的两级页表</h6>
<p>两级分页的逻辑地址结构: 页表页号(页目录号) + 页号 + 页内偏移地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225230425930.png" alt="image-20231225230425930"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231225235223990.png" alt="image-20231225235223990"></p>
<h6 id="两级分页中的地址转换">两级分页中的地址转换</h6>
<p>虚拟地址(逻辑地址)结构中分离出根页表号</p>
<p>检索根页表, 查找关于用户页的页表项</p>
<ul>
<li>如果不在内存产生一次缺页中断</li>
<li>若在内存, 用虚拟地址中间页号就按所用户页表, 查找对应的页表项</li>
</ul>
<p>得到页框号, 和页内偏移量一起形成物理地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226002033592.png" alt="image-20231226002033592"></p>
<h5 id="多级页表">多级页表</h5>
<p>对某些机器, 二级页表也可能很大</p>
<ul>
<li>采用多级页表, 对外层页表再进行分页</li>
</ul>
<p>建立多级页表</p>
<ul>
<li>会增加额外的存储空间</li>
<li>页表的级数越多, 地址转换过程越复杂, 转换的速度也越慢</li>
</ul>
<h5 id="倒置页表">倒置页表</h5>
<ul>
<li>
<p>虚拟地址的页号部分用一个简单的散列函数映射到散列表中</p>
<p>哈希值指向倒排页表</p>
</li>
<li>
<p>无论有多少进程, 支持多少虚拟页, 页表都只需要实存中的一个固定部分</p>
</li>
<li>
<p>页表结构称为&quot;倒排&quot;的原因: 使用页框号而非虚拟页号来索引页表项</p>
</li>
</ul>
<h6 id="倒置页表结构">倒置页表结构</h6>
<p>页号 + 进程标志符 + 控制位 + 链指针</p>
<p>进程标志符指出使用该页的进程, 控制位作标记如有效, 访问与修改, 保护与锁定, 链指针为下一项的索引值</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226005325067.png" alt="image-20231226005325067"></p>
<h5 id="转换检测缓冲区tlb-translation-lookaside-buffer-快表">转换检测缓冲区TLB(translation lookaside buffer 快表)</h5>
<p>每次虚存访问都可能会引起两次物理地址访问</p>
<ul>
<li>一次取相应的页表项</li>
<li>另一次取需要的数据</li>
</ul>
<p>为了克服这个问题, 大多数虚拟内存文案都为页表项使用了一个特殊的高速缓存, 称为转换检测缓冲区TLB(快表), TLB包含最近用过的页表项</p>
<h6 id="具有快表的地址转换流程">具有快表的地址转换流程</h6>
<ul>
<li>给定一个虚拟地址, 处理器首先检查TLB</li>
<li>若命中: 即页表项在TLB中, 检索页框号形成物理地址</li>
<li>若未命中: 即页表项不在TLB中, 检索进程页表, 查找相应页表项
<ul>
<li>若&quot;存在位&quot;已置位, 页位于内存, 用页框号+偏移量形成物理地址</li>
<li>若&quot;存在位&quot;未置位, 页不在内存, 产生缺页中断, 装入所需页, 更新页表</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226012148498.png" alt="image-20231226012148498"></p>
<p>具有快表的地址转换流程图</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226012158384.png" alt="image-20231226012158384"></p>
<h6 id="页表项的直接查找和关联查找-tlb查找">页表项的直接查找和关联查找(TLB查找)</h6>
<ul>
<li>TLB包含整个页表中的部分表项, 必须包括页号和完整的页表项, 所以不能简单地将页号编入TLB的索引</li>
<li>处理器的硬件机制允许同时查询许多TLB页, 以确定是否存在匹配的页号</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226012615843.png" alt="image-20231226012615843"></p>
<h6 id="tlb操作和内存高速缓存-cache-操作">TLB操作和内存高速缓存(Cache)操作</h6>
<p>单词访问内存设计CPU硬件的复杂性</p>
<ul>
<li>页表项可能在TLB, 也可能在内存或磁盘中</li>
<li>被访问的字可能在高速缓存中, 也可能在内存或磁盘中</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226012843946.png" alt="image-20231226012843946"></p>
<h5 id="页尺寸">页尺寸</h5>
<ul>
<li>页越小, 内部碎片的总量越少, 每个进程需要的页的数量越多</li>
<li>页数量越多, 进程的页表越大</li>
<li>页数量越多, 进程的页表越大</li>
<li>多道程序设计环境中的大程序, 意味着活动进程有一部分页表在虚存而非内存, 则一次内存访问可能产生两次缺页中断
<ul>
<li>依次读取所需页表</li>
<li>依次读取进程页</li>
</ul>
</li>
<li>基于辅存设备的物理特性, 希望页尺寸比较大, 从而实现更有效的数据传输</li>
</ul>
<h6 id="缺页率">缺页率</h6>
<p>缺页率: 发生缺页的次数与总访问次数的比值</p>
<p>缺页率与页尺寸的关系</p>
<ul>
<li>页尺寸很小时, 缺页率低.			每个进程由较多数量的页, 内存中的页都包含有最近访问的部分</li>
<li>页尺寸增加时, 缺页率增加         页尺寸增加时, 每页包含的单元和最近访问过的单元变远, 局部性原理的影响被削弱</li>
<li>页尺寸较大时, 缺页率下降         页尺寸接近整个进程的大小时, 一页包含整个进程不会发生缺页中断</li>
</ul>
<p>缺页率与分配页框数的关系</p>
<ul>
<li>对固定的页尺寸, 当分配给进程的页框数增加时, 缺页率下降</li>
</ul>
<p>大型程序中所用的当代程序设计技术可能降低程序的局部性, 解决方法</p>
<ul>
<li>面向对象技术: 对小程序和数据的引用会分散在不同的对象中</li>
<li>多线程应用: 指令流突然变化, 引用分散在内存中</li>
</ul>
<h4 id="分段">分段</h4>
<p>允许程序员把内存视作由多个地址空间或段组成</p>
<p>段大小不等, 可以动态变化</p>
<p>内存访问时, 短号+ 段内偏移量</p>
<p>分段优点</p>
<ol>
<li>简化了对不断增长的数据结构的处理</li>
<li>允许程序独立地改变或重新编译</li>
<li>有助于进程间的共享</li>
<li>有助于保护</li>
</ol>
<h5 id="段的组织">段的组织</h5>
<p>每个进程一个段表, 每个段表项包括</p>
<ul>
<li>
<p>存在位P, 标识响应的段是否位于内存</p>
<p>是, 段表项还包括</p>
<ul>
<li>段基址:相应段在内存中的起始地址</li>
<li>段长度</li>
</ul>
</li>
<li>
<p>修改位M, 标识相应的段是否被修改</p>
<ul>
<li>是, 换出时写回辅存</li>
<li>否, 换出时不需写回</li>
</ul>
</li>
<li>
<p>其他控制位, 如用于保护和共享</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226015629565.png" alt="image-20231226015629565"></p>
<h5 id="分段系统中的地址转换">分段系统中的地址转换</h5>
<ul>
<li>逻辑地址 = 段号 + 段内偏移量, 寄存器存储段表地址</li>
<li>物理地址 = 基地址 + 段内偏移量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226015821382.png" alt="image-20231226015821382"></p>
<h4 id="段页式">段页式</h4>
<p>用户的地址空间划分成许多段, 每段划分为许多固定大小的页</p>
<ul>
<li>
<p>分段对程序员可见</p>
<p>支持数据结构增长:段长可变</p>
<p>支持共享和保护</p>
</li>
<li>
<p>分页对程序员透明</p>
<p>消除外部碎片</p>
<p>有效利用内存</p>
</li>
</ul>
<h5 id="段页式的逻辑地址">段页式的逻辑地址</h5>
<p>程序员角度: 逻辑地址 = 段号 + 段内偏移量</p>
<p>系统角度: 段内偏移量 = 页号 + 页号偏移量</p>
<h6 id="段表和页表">段表和页表</h6>
<p>每个进程一个段表</p>
<p>每个段一个页表</p>
<p>段表项: 含段长和对应页表的起始地址</p>
<p>页表项:含页框号, 存在位P, 修改位M等</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226020432934.png" alt="image-20231226020432934"></p>
<p><strong>段页式的地址转换</strong></p>
<p>虚拟地址/逻辑地址 = 段号 + 页号 + 偏移量, 寄存器存放段表起始地址</p>
<p>根据段表起始地址和段号查找段表, 得到对应段的页表起始地址</p>
<p>根据页表起始地址和页号查找页表, 得到页框号</p>
<p>页框号和偏移量构成物理地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226021217853.png" alt="image-20231226021217853"></p>
<p>段页式系统中, 获取一条指令或数据, 至少要访问三次内存</p>
<ol>
<li>访问段表, 从中获得该段的页表首址</li>
<li>访问页表, 从中取出逻辑地址指定的页面所在页框号</li>
<li>根据物理地址, 取出对应存储单元的指令或数据</li>
</ol>
<h4 id="保护与共享">保护与共享</h4>
<p>分段有助于实现保护和共享机制</p>
<p>保护: 每个段都包括一个长度和基地址, 可以控制非法访问</p>
<p>共享: 一个段可以在多个进程的段表中被引用, 实现共享</p>
<p>分段有助于实现共享</p>
<ul>
<li>分页: 假定每个页面4KB, 160KB的共享代码需要40个页面, 每个进程需要40个页表项来存储相应信息</li>
<li><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226021901736.png" alt="image-20231226021901736"></li>
<li>分段: 共享部分作为一个段, 每个进程仅需一个段表项来存放共享段信息</li>
<li><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226021910346.png" alt="image-20231226021910346"></li>
</ul>
<p>段间保护关系: 每个段表项包括一个长度和一个基地址, 程序不会不经意地超过该段的内存单元 – 段结构对程序员可见</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226022510106.png" alt="image-20231226022510106"></p>
<h3 id="操作系统软件">操作系统软件</h3>
<p>内存管理设计的三个基本选择:</p>
<ol>
<li>
<p>是否使用虚拟技术</p>
</li>
<li>
<p>分页, 分段还是段页式</p>
</li>
<li>
<p>为各种存储管理特征采用的算法</p>
<p>术语OS软件领域的问题, 是本节的主题</p>
</li>
</ol>
<p>为实现虚拟内存, OS需要考虑的软件策略</p>
<ol>
<li>
<p>读取策略</p>
<ul>
<li>请求调页</li>
<li>预调页</li>
</ul>
</li>
<li>
<p>放置策略</p>
<p>预留在内存中的位置</p>
</li>
<li>
<p>置换策略</p>
<p>基本算法</p>
<ul>
<li>最优OPT</li>
<li>最近最少使用LRU</li>
<li>先进先出FIFO</li>
<li>时钟CLOCK</li>
</ul>
<p>页缓冲</p>
</li>
<li>
<p>驻留集管理</p>
<p>驻留集大小</p>
<ul>
<li>固定</li>
<li>可变</li>
</ul>
<p>置换范围</p>
<ul>
<li>全局</li>
<li>局部</li>
</ul>
</li>
<li>
<p>清除策略</p>
<ul>
<li>请求式清除</li>
<li>预约式清除</li>
</ul>
</li>
<li>
<p>负载控制</p>
<p>多道程序度(系统并发度)</p>
</li>
</ol>
<h4 id="读取策略">读取策略</h4>
<ul>
<li>请求调页</li>
<li>预调页</li>
</ul>
<h5 id="请求调页">请求调页</h5>
<p>仅在引用页面时, 才把相应的页面调入内存</p>
<p>进程首次启动时, 会发生很多缺页中断</p>
<p>局部性原则表明, 大多数将来访问的页面都是最近读取的页面, 一段时间后, 缺页中断会降低到很低的水平</p>
<h5 id="预调页">预调页</h5>
<p>额外读取所缺页面以外的页面</p>
<p>考虑辅存设备的特性: 寻道, 旋转延迟</p>
<p>若进程的页面连续存储在辅存中, 则一次读取多个页面会更有效</p>
<p>若额外读取的页面未使用, 则低效</p>
<h4 id="放置策略">放置策略</h4>
<p>确定进程驻留在内存中的位置</p>
<p>分段系统中的重要设计内容, 如首次匹配和循环匹配</p>
<p>硬件以相同的效率执行地址转换功能, 所以分页或段内分页是无关紧要的</p>
<p>对于非一致性存储访问, 需要自动放置策略</p>
<h4 id="置换策略">置换策略</h4>
<p>页面置换设计的问题:具体淘汰哪个页面用以置换</p>
<p>置换策略</p>
<ul>
<li>
<p>读取新页时, 如何选择内存要淘汰的页面</p>
<p>目标: 最近最不可能访问的页面</p>
</li>
<li>
<p>置换策略越精细, 硬件和软件开销越大</p>
</li>
</ul>
<p>页框锁定</p>
<ul>
<li>页框锁定时, 当前存储在该页框中的页面不能被置换</li>
<li>OS内核和重要的数据结构保存在锁定的页框中</li>
<li>I/O缓冲区和时间要求严格的区域也可能保存在锁定的页框中</li>
<li>通过将锁定位与每个页框相关联来实现锁定</li>
</ul>
<p>几种基本的置换算法</p>
<ol>
<li>最佳OPT Optimal</li>
<li>最近最少使用LRU Least recently used</li>
<li>先进先出FIFO Firsr-in-first-out</li>
<li>时钟CLOCK</li>
</ol>
<p>评价置换算法的指标 – 缺页率: 给定时间内, 发生缺页的次数与访问总次数的比值</p>
<h5 id="最佳opt">最佳OPT</h5>
<p>置换下次访问句当前时间最长的页面</p>
<p>理想算法, 缺页率最少</p>
<p>由于奥球OS必须知道将来的事件, 因此不可能实现</p>
<p>F表示产生缺页中断</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226100734019.png" alt="image-20231226100734019"></p>
<h5 id="最近最少使用lru">最近最少使用LRU</h5>
<p>置换内存中最长时间未引用的的页面</p>
<p>根据局部性原理, 这也是最近最不可能访问的页面</p>
<p>难以实施</p>
<ul>
<li>每页添加最近访问时间戳 – 开销大</li>
<li>建立链表 – 开销大</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226101343304.png" alt="image-20231226101343304"></p>
<h5 id="先进先出fifio">先进先出FIFIO</h5>
<p>将分配给进程的页框视为循环缓冲区</p>
<p>页面以循环方式删除 – 简单的置换策略</p>
<p>置换驻留在内存中时间最长的页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226101506186.png" alt="image-20231226101506186"></p>
<h5 id="时钟clock">时钟CLOCK</h5>
<p>每个页框关联一个使用位U(也称访问位)</p>
<p>页面首次加载到内存中或被引用时, 使用位U设置为1</p>
<p>用于置换的候选页框视作一个循环缓冲区</p>
<p>发生缺页中断时</p>
<ul>
<li>检查表针指向页面, 若使用位为0, 则新页面替换之</li>
<li>如果使用位为1, 则清0, 表针前移一个位置</li>
<li>重复以上过程</li>
</ul>
<p>注意: 命中时, 表针不移动</p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226102027700.png" alt="image-20231226102027700"></p>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226103023446.png" alt="image-20231226103023446"></p>
<h5 id="几种置换算法的比较-固定分配-局部置换">几种置换算法的比较(固定分配, 局部置换)</h5>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226103628625.png" alt="image-20231226103628625"></p>
<h5 id="改进的clock算法">改进的CLOCK算法</h5>
<p>在CLOCK算法基础上, 优先置换最近未访问, 未修改的页面</p>
<p>每个页框处于下列情形之一(u:使用位/访问位, m:修改位)</p>
<ol>
<li>u=0, m=0: 最近未被访问, 又未被修改, 最佳淘汰页</li>
<li>u=0, m=1</li>
<li>u=1, m=0</li>
<li>u=1, m=1</li>
</ol>
<h6 id="算法流程">算法流程</h6>
<ol>
<li>从指针当前位置开始扫描, 这次扫描对使用位不修改, 选择遇到的第一个u=0, m=0页框置换</li>
<li>若第1步事变, 重新扫描, 选择遇到的第一个u=0, m=1的页框置换. 这一过程中, 使每个扫描过的页框u置0</li>
<li>若第2步失败, 重新扫描重复1</li>
</ol>
<h5 id="页缓冲">页缓冲</h5>
<p>置换的页, 如果要写回辅存, 代价较大</p>
<p>在内存中使用页缓冲, 提高分页性能, 允许使用更简单的页面替换策略</p>
<p>置换的页面仍在内存中</p>
<ul>
<li>未修改, 放入空闲页链表尾部</li>
<li>已修改, 放入修改页链表尾部</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226104555599.png" alt="image-20231226104555599"></p>
<h5 id="置换策略和高速缓存大小">置换策略和高速缓存大小</h5>
<p>若选择替换的页在高速缓存中, 则该高速缓存块和内存中对应的页将失效</p>
<p>在使用页缓冲的系统重, 可以使用页缓冲区中的页放置策略来提高高速缓存性能</p>
<p>大多数OS通过从页缓冲区中选择任意页框来放置高速缓存中需置换的页</p>
<h4 id="驻留集管理">驻留集管理</h4>
<p>页框分配, 即给每个活动分配多少页框</p>
<ul>
<li>分配给每个进程的内存越小, 可以驻留在内存中的进程越多</li>
<li>若一个进程在内存中的页面少, 则缺页率相对较高</li>
<li>给进程分配的页框数超出一定大小后, 由于局部性原理, 缺页率下降到稳定水平</li>
</ul>
<p>置换范围, 即计划置换的页集局限于产生缺页的进程本身, 还是内存内的所有进程</p>
<ul>
<li>局部置换: 仅在缺页中断的进程的驻留页中选择置换对象</li>
<li>全局置换: 在整个内存中选择置换对象, 只要不是锁定的页, 都可以作为候选页</li>
</ul>
<p>页框分配策略</p>
<ul>
<li>
<p>固定分配: 在内存中为进程提供固定数量的页框</p>
<p>发生缺页时, 必须替换该进程的其中一个页面</p>
</li>
<li>
<p>可变分配</p>
<p>允许分配给进程的页框数在进程的生命周期内变化</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226111605036.png" alt="image-20231226111605036" style="zoom:67%;" />
<h5 id="固定分配-局部置换">固定分配, 局部置换</h5>
<p>事先确定分配给一个进程的页框数量</p>
<p>如果进程分配的数量太少, 产生较高缺页率</p>
<p>如果分配的页框数太多, 内存中只能有较少的程序</p>
<ul>
<li>增加了处理器的空闲时间</li>
<li>增加了交换的时间</li>
</ul>
<h5 id="可变分配-全局置换">可变分配, 全局置换</h5>
<p>最容易实现的方法, 在很多OS中使用</p>
<p>OS维护一个空闲页框列表</p>
<p>缺页中断发生时, 一个空闲页框分配给缺页的进程</p>
<p>若没有空闲页框, OS选择一个内存中的页框(未被锁定, 没有被内核占用)作为置换对象</p>
<p>选择置换对象不当, 容易再次产生缺页中断, 使用页缓冲可以缓解问题</p>
<h5 id="可变分配-局部置换">可变分配, 局部置换</h5>
<p>新进程装入内存时, 分配一定页框作为驻留集</p>
<p>缺页中断发生时, 从进程驻留集中选择一页用于置换</p>
<p>不时重新评估进程的页框分配情况, 增加或减少分配的页框</p>
<p>关键要素</p>
<ul>
<li>决定驻留集大小的原则</li>
<li>驻留集大小变化的时机</li>
</ul>
<h5 id="工作集">工作集</h5>
<ul>
<li>一个进程在某一段时间内访问页面的集合。</li>
<li>如果页面正在使用，它就落在工作集中；</li>
<li>如果不再使用，它将不出现在相应的工作集中，所以，工作集是程序局部性的近似表示。</li>
<li>工作集避免抖动方法
<ul>
<li>OS监视每个进程的工作集
<ul>
<li>新增页面分配内存。</li>
<li>淘汰不在工作集中的页面。</li>
</ul>
</li>
<li>若有足够多的额外内存块，就可装入另一个进程。</li>
<li>如果所有工作集之和超过了可用内存，则OS选择挂起一个进程，把它的页换出，将其内存块分配给其它进程。</li>
<li>工作集的估算不容易：Δ</li>
</ul>
</li>
</ul>
<h6 id="平均访问时间-平均有效访问时间">平均访问时间/平均有效访问时间</h6>
<p>若缺页率为p, 内存访问时间为ma, 发生缺页时的访问时间为da, 则平均访问时间 = (1-p)*ma + p*da</p>
<p>发生缺页时访问时间的构成:</p>
<ul>
<li>缺页中断服务时间</li>
<li>页面写出时间(若需置换)</li>
<li>页面调入时间 – 20ms(寻道时间 + 旋转时间 + 数据传送时间)</li>
<li>重新访问内存指令时间</li>
</ul>
<p>由于ma很小(&lt;10ns), 因此很低的缺页率也会导致很大的平均访问时间</p>
<h2 id="第四章-i-o管理与磁盘调度">第四章 I/O管理与磁盘调度</h2>
<h3 id="i-o控制方式">I/O控制方式</h3>
<ul>
<li>程序I/O方式</li>
<li>中断驱动I/O方式</li>
<li>直接存储器访问(DMA)方式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/421zuoduan/blog-imgs@main/imgs/image-20231226185912000.png" alt="image-20231226185912000"></p>
<h4 id="i-o通道控制方式">I/O通道控制方式</h4>
<p>一个设备可以连接到多个控制上, 而一个控制器又连接到多个通道上</p>
<h3 id="操作系统的设计问题">操作系统的设计问题</h3>
<h3 id="i-o缓冲">I/O缓冲</h3>
<h2 id="选填专题">选填专题</h2>
<h3 id="第一章-绪论">第一章 绪论</h3>
<p>计算机系统结构</p>
<ol>
<li>硬件</li>
<li>操作系统</li>
<li>系统程序</li>
<li>应用程序</li>
<li>用户</li>
</ol>
<p>OS的目标: <code>方便性</code>, <code>有效性</code>, <code>扩展性</code>, <code>开放性</code></p>
<h3 id="第二章-进程1-描述">第二章 进程1–描述</h3>
<p>操作系统的基本特征 <code>并发性</code> <code>共享性</code> <code>异步性(不确定性)</code> <code>虚拟性</code></p>
<p>进程是<code>资源申请</code>和<code>系统调度</code>的基本单位</p>
<p>阻塞状态/等待状态: 进程因等待某种事件的发生而暂时不能继续运行的状态</p>
<p>操作系统内核: 操作系统中包含重要系统功能的部分</p>
<p>操作系统内核功能</p>
<ol>
<li>资源管理功能
<ul>
<li>进程管理</li>
<li>存储管理</li>
<li>I/O设备管理</li>
</ul>
</li>
<li>支撑功能
<ul>
<li>中断处理</li>
<li>时钟管理</li>
<li>记账(统计, 监测)功能</li>
</ul>
</li>
</ol>
<p>进程控制块PCB – 进程存在的唯一标识, 常驻内存, 是一个数据结构</p>
<p>PCB包含三类信息</p>
<ol>
<li>进程标识符: 唯一地标识一个进程</li>
<li>处理机状态信息: 由处理器的各种寄存器中的内容组成的</li>
<li>进程控制信息: 与进程调度和进程切换有关的信息</li>
</ol>
<p>进程的组成</p>
<ul>
<li><code>程序</code></li>
<li><code>数据</code>, 如变量, 工作空间, 缓冲区</li>
<li><code>执行上下文</code>
<ul>
<li>进程状态</li>
<li>OS管理和控制进程所需的所有数据</li>
<li>如处理器寄存器的内容, 进程优先级, 是否在等待I/O事件, 在内存中的位置</li>
<li>进程需要数据结构来保存进程的上下文环境</li>
</ul>
</li>
</ul>
<p>执行模式包括<code>内核/系统/控制模式</code>和<code>用户模式</code></p>
<p>内核态和用户态, 阻塞态和就绪态, 是两套独立描述进程的东西, 一个是进程状态, 一个是执行模式</p>
<p>进程切换必然导致模式切换, 模式切换不一定伴随进程切换</p>
<p>进程的创建</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配资源(内存, 文件)</li>
<li>初始化PCB数据结构</li>
<li>将新进程插入就绪队列</li>
</ol>
<p>进程的终止</p>
<ol>
<li>检索PCB, 检查进程状态</li>
<li>若为执行态, 则中止, 调度下一个就绪进程执行</li>
<li>若有子孙, 则终止子孙</li>
<li>归还资源给父进程或系统</li>
<li>从PCB队列中移出PCB</li>
</ol>
<p>何时发生进程切换</p>
<ol>
<li>时钟中断</li>
<li>I/O中断</li>
<li>内存失效</li>
<li>陷阱</li>
<li>系统调用(与用户/内核模式切换的区别)</li>
</ol>
<p>子进程是父进程的<code>精确复制</code></p>
<p>进程的两个基本属性 <code>拥有资源的独立单位</code>和<code>调度/执行的基本单位</code></p>
<p>进程是<code>拥有资源</code>和<code>独立运行</code>的基本单位</p>
<p>线程是<code>系统独立调度和分派</code>的单位</p>
<p>调度类型</p>
<ol>
<li>
<p>长程调度</p>
<p>新建任务, 外存作业调入内存</p>
</li>
<li>
<p>中程调度</p>
<p>内外存对换, 进程挂起</p>
</li>
<li>
<p>短程调度</p>
<p>就绪队列中哪个进程执行</p>
</li>
</ol>
<p>调度的评价准则</p>
<ul>
<li>面向用户准则
<ol>
<li>响应时间: 提交到系统首次响应</li>
<li>周转时间: 提交到系统完成
<ul>
<li>平均周转时间</li>
<li>带权周转时间</li>
<li>平均带权周转时间</li>
</ul>
</li>
<li>截止时间: 必须开始执行的最迟时间</li>
</ol>
</li>
<li>面向系统准则
<ol>
<li>处理机利用率</li>
<li>系统吞吐量: 单位时间内, 系统完成的作业数</li>
<li>公平性</li>
<li>优先权</li>
<li>资源平衡利用</li>
</ol>
</li>
</ul>
<h3 id="第二章-进程3-同步">第二章 进程3–同步</h3>
<p>同步原则</p>
<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待: 在临界区不能长时间阻塞等待某事件</li>
</ol>
<p>生产者/消费者问题, 要先申请资源, 再申请访问权</p>
<h3 id="第二章-进程4-死锁">第二章 进程4–死锁</h3>
<p>产生死锁的原因</p>
<ol>
<li>资源不足导致的资源竞争</li>
<li>并发执行的顺序不当</li>
</ol>
<p>死锁的四个必要条件</p>
<ol>
<li>互斥</li>
<li>占有且等待</li>
<li>非抢占</li>
<li>循环等待(充要条件)</li>
</ol>
<p>进程回退:把死锁进程备份到前面定义的某些检查点, 并且重新启动所有进程 - 需要系统构造重新运行和重新启动机制</p>
<h3 id="第三章-内存1-基本">第三章 内存1–基本</h3>
<p>存储管理的基本功能</p>
<ol>
<li>存储分配和回收</li>
<li>地址变换</li>
<li>存储保护</li>
<li>存储共享</li>
<li>存储器扩充</li>
</ol>
<p>高级语言的源代码转化为进程的三个基本步骤</p>
<ol>
<li>编译: 编译程序将用户源代码编译成若干个目标模块</li>
<li>链接: 由链接程序将编译后形成的一组目标模块, 以及所需库函数链接在一起, 形成一个完整的装入模块</li>
<li>装入: 由装入程序将装入模块装入物理内存</li>
</ol>
<p>程序的链接</p>
<ol>
<li>
<p>静态链接</p>
<p>需要修改相对地址, 变换外部调用符号</p>
</li>
<li>
<p>动态链接</p>
<ul>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
</li>
</ol>
<p>装入方式(程序加载)</p>
<ol>
<li>绝对装入方式</li>
<li>重定位装入</li>
<li>运行时装入</li>
</ol>
<p>重定位: 在装入时对目标程序中指令和数据的变换过程称为重定位</p>
<p>连续分配</p>
<ol>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>动态分区分配</li>
<li>可重定位分区分配</li>
</ol>
<p>覆盖: 一个程序的几个代码段或数据段, 按照时间先后占用公共的内存空间</p>
<p>页表: 实现逻辑页号到物理块号的映射</p>
<p>每个进程拥有一个页表/页表, 其信息(如长度, 开始地址)放在PCB中, 执行时页表始址和页表长度装入<code>页表寄存器</code></p>
<p>页表在内存, 属于进程的内核信息</p>
<p>分段式便于</p>
<ol>
<li><code>编写程序</code></li>
<li><code>分段共享</code></li>
<li><code>分段保护</code></li>
<li><code>动态链接</code></li>
<li><code>动态增长</code></li>
</ol>
<p>含有快表的平均访存时间, 下面n代表n级页表</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均访存时间</mtext><mo>=</mo><mi>T</mi><mi>L</mi><mi>B</mi><mtext>命中率</mtext><mo>∗</mo><mo stretchy="false">(</mo><mi>T</mi><mi>L</mi><mi>B</mi><mtext>访问时间</mtext><mo>+</mo><mn>1</mn><mtext>次访存时间</mtext><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>T</mi><mi>L</mi><mi>B</mi><mtext>命中率</mtext><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>T</mi><mi>L</mi><mi>B</mi><mtext>访问时间</mtext><mo>+</mo><mi>n</mi><mtext>次页表访问时间</mtext><mo>+</mo><mn>1</mn><mtext>次访存时间</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">平均访存时间 = TLB命中率 * (TLB访问时间 + 1次访存时间) + (1-TLB命中率) * (TLB访问时间 + n次页表访问时间 + 1次访存时间)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">率</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="第三章-内存2-虚拟内存">第三章 内存2–虚拟内存</h3>
<p>局部性原理:</p>
<ul>
<li>时间局限性: 程序中存在着大量的循环操作</li>
<li>空间局限性: 以单纯恒旭访问了某个存储单元, 不久后附近的存储单元也将被访问</li>
</ul>
<p>请求分页存储管理方式, 请求分页中的<code>硬件支持</code>需要</p>
<ol>
<li>一台具有一定容量内存和外存的<code>计算机系统</code></li>
<li><code>页表机制</code></li>
<li><code>缺页中断机构</code></li>
<li><code>地址变换机构</code></li>
</ol>
<p>内存分配的分配策略(指如何给程序分占用的物理块块数): <code>固定分配</code>, <code>可变分配</code></p>
<p>内存分配的置换策略(逻辑上发现缺页, 从哪里寻找物理块): <code>全局置换</code>, <code>局部置换</code></p>
<p>分配策略和置换策略可以组合出三种策略</p>
<ol>
<li><code>固定分配局部置换</code></li>
<li><code>可变分配全局置换</code></li>
<li><code>可变分配局部置换</code></li>
</ol>
<p>内存分配的分配算法: <code>平均分配</code>, <code>按程序大小比例分配</code>, <code>按优先级分配</code></p>
<p>页面置换算法</p>
<ol>
<li><code>OPT最优置换算法</code></li>
<li><code>FIFO先进先出算法</code></li>
<li><code>LRU最近最久未使用算法</code></li>
<li><code>CLOCK算法</code></li>
</ol>
<p>抖动的现象</p>
<ol>
<li>页面被频繁地换入换出, 缺页率急剧增加</li>
<li>页面有效存取时间加长</li>
<li>系统吞吐量骤减</li>
</ol>
<p>抖动的根本原因: 多道程序度过高, 每个进程分配的页框数目过少</p>
<p>抖动的预防</p>
<ol>
<li>采用局部置换策略</li>
<li>CPU调度程序中运用工作集算法</li>
<li>L=S准则, 发生缺页的平均时间L = 处理缺页故障的平均时间S</li>
<li>挂起若干进程</li>
</ol>
<p>工作集: 一个进程在某短时间内访问页面的集合, 工作集是程序局部性的近似表示</p>
<p>工作集避免抖动方法</p>
<ol>
<li>OS监视每个进程的工作集</li>
<li>若有足够多的内存块, 可装入另一个进程</li>
<li>若所有工作集之和超过了可用内存, OS选择挂起一个进程, 换出页, 将其内存块分配给其他进程</li>
<li>工作集的估算不容易</li>
</ol>
<p>虚拟存储器的特征</p>
<ol>
<li><code>多次性</code>, 多次调入内存运行</li>
<li><code>对换性</code>, 运行中存在换进换出</li>
<li><code>虚拟性</code>, 逻辑上扩充内存容量</li>
</ol>
<h3 id="第四章-设备">第四章 设备</h3>
<p>各类I/O设备在<code>数据传输速率</code>, <code>用途</code>, <code>控制接口复杂性</code>, <code>传输单元(字节流, 块)</code>, <code>数据编码方式</code>, <code>错误</code>等方面都存在差异</p>
<p>四种执行I/O的技术</p>
<ol>
<li>程序控制I/O</li>
<li>中断驱动I/O</li>
<li>直接内存访问DMA: 允许外设绕过CPU直接修改内存的一种带中断的技术</li>
<li>I/O通道方式</li>
</ol>
<p>中断驱动I/O方式不适用于块设备: 过于频繁的中断</p>
<p>I/O通道控制方式, 通道是一个独立于CPU的专管I/O控制的<code>处理机</code>, 有自己的通道指令集,通过<code>通道程序</code>控制I/O, 以<code>一个数据块</code>为单位的读写, 改进为<code>一组数据块</code>为单位的读写</p>
<p>设备管理中, 引入缓冲区的主要原因</p>
<ol>
<li>缓和CPU与I/O设备速度不匹配的矛盾</li>
<li>减少对CPU的中断频率, 放宽对CPU中断响应时间的限制</li>
<li>提高CPU和I/O设备间的并行性</li>
</ol>
<p>为了避免<code>死锁</code>和<code>丢失数据</code>等问题, 一些进程和虚拟地址单元被锁定在内存中, 直到I/O执行结束. 为避免这些开销和低效的操作, 提出缓冲技术</p>
<p>缓冲:</p>
<ol>
<li>在输入请求发出前开始输入传送</li>
<li>输出请求发出后一段时间后才开始执行输出传送</li>
</ol>
<p>为了实现<code>双向数据传输</code>, 必须在两台机器中都设置两个<code>缓冲区</code>, 一个用作发送缓冲区, 一个用作接收缓冲区</p>
<p>缓冲的作用: 缓解I/O设备速度与CPU速度不匹配的矛盾</p>
<p>SPOOLing: 在<code>联机</code>情况下实现的<code>同时外围操作</code>, 或称假脱机操作</p>
<p>SPOOLing系统的特点</p>
<ol>
<li>提高I/O速度</li>
<li>将独占设备改造成共享设备</li>
<li>实现了虚拟设备功能</li>
</ol>
<p>SPOOLing的I/O缓冲区建立在<code>磁盘</code>中, 将一台独占I/O的物理设备<code>虚拟</code>为多台逻辑I/O设备, 实现<code>设备共享</code>. 通过将<code>对低速I/O设备的操作</code>转化为<code>对输入/输出井中数据的存取</code>, 缓和了CPU与低速I/O设备间速度不匹配的问题</p>
<p>设备的硬件层次结构</p>
<ol>
<li>用户层软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
<li>硬件</li>
</ol>
<p>磁盘管理:</p>
<ul>
<li><code>存储面</code>: 每个磁片分一个或两个存储面</li>
<li><code>磁道</code>: 每个磁盘面被组织成若干个同心环</li>
<li><code>扇区</code>: 每条磁道逻辑上划分成若干个扇区</li>
<li><code>柱面</code>: 不同盘面相同的磁道称为柱面</li>
<li><code>读写头</code>: 分为固定头和移动头</li>
</ul>
<p>磁盘调度的目的: 减少寻道时间</p>
<p>磁盘调度</p>
<ol>
<li>先进先出-FIFO</li>
<li>优先级-PRI</li>
<li>后进先出-LIFO</li>
<li>最短寻道时间优先-SSTF</li>
<li>扫描-SCAN(电梯调度算法), 掉头条件改为&quot;前方没有要处理的其他请求&quot;称为LOOK</li>
<li>循环扫描-C-SCAN, 单向扫描</li>
<li>N步SCAN, 请求队列分成N个子队列, 依次处理</li>
<li>FSCAN, 两个子队列, 新请求放在另一个</li>
</ol>
<p><code>磁盘高速缓存</code>: 内存中为磁盘扇区设置的一个缓冲区, 包含磁盘中某些扇区的副本</p>
<p>磁盘高速缓存的两种置换策略</p>
<ol>
<li>最近最少使用算法-LRU</li>
<li>最不常使用算法-LFU</li>
</ol>
<p>DMA的寄存器包括<code>命令/状态寄存器</code>, <code>内存地址寄存器</code>, <code>数据寄存器</code></p>
<h3 id="第五章-文件">第五章 文件</h3>
<p><code>文件</code>: 一种具有符号名的, 相关联元素的有序集合</p>
<p>文件是<code>信息在磁盘上存储的基本逻辑单位</code></p>
<p>文件 = <code>元数据</code> + <code>内容数据</code>, 元数据记录的是文件属性如文件名拥有者访问权限文件大小</p>
<p>文件系统管理的对象: <code>文件(直接对象)</code>, <code>目录</code>, <code>磁盘存储空间</code></p>
<p>文件系统的实现模型: &quot;<code>文件系统接口-</code>逻辑功能层<code>-</code>物理驱动层`&quot;三层组成</p>
<p>文件系统的主要目的: 实现对文件的按名存取</p>
<p>文件结构</p>
<ul>
<li>逻辑结构: <code>用户</code>角度研究文件的组织形式
<ul>
<li>流式文件(非结构化文件), 如txt, 以字节为基本组成单位</li>
<li>记录文件(结构化文件), 按记录的组织形式又分类为
<ol>
<li>堆文件, 按记录到达的时间先后顺序存储</li>
<li>顺序文件, 记录长度固定, 各域含义固定, 记录按&quot;关键域&quot;有序排列</li>
<li>索引顺序文件, 是一个顺序文件, 每组一个索引而不是每条记录一个索引, 添加<code>索引表</code>和<code>溢出文件</code>, 组与组间记录的关键字必须<code>有序排列</code>.插入记录时放在<code>溢出文件</code>中,  批处理方式合并溢出文件</li>
<li>索引文件, 解决了顺序文件对非关键域查找困难的问题</li>
<li>哈希(直接)文件: 适用于<code>快速访问</code>, <code>记录定长</code>, <code>每次只访问一个记录</code>的场景</li>
</ol>
</li>
</ul>
</li>
<li>物理结构</li>
</ul>
<p>辅存管理</p>
<ol>
<li>文件分配</li>
<li>辅存中的空闲空间管理</li>
</ol>
<p>记录组块方式</p>
<ol>
<li>定长组块</li>
<li>变长跨越式组块</li>
<li>变长非跨越式组块</li>
</ol>
<p>文件组织形式</p>
<ol>
<li>堆文件</li>
<li>顺序文件</li>
<li>索引顺序文件</li>
<li>索引文件</li>
<li>直接文件/散列文件/哈希文件</li>
</ol>
<p><code>文件目录</code>是<code>文件目录项</code>的有序集合</p>
<p>文件分配方式(物理结构), 分配内存时的方式</p>
<ol>
<li>连续分配</li>
<li>链式分配</li>
<li>索引分配</li>
</ol>
<p>空闲空间管理方法</p>
<ol>
<li>空闲表法</li>
<li>空闲链表法</li>
<li>位示图法</li>
<li>成组链接法</li>
</ol>
<p>位示图占用的存储空间大小 = 磁盘容量(字节数) / (8 * 数据块大小)</p>
<p>FCB: 描述和控制文件的数据结构, 与文件一一对应, 是文件存在的标志, 包括以下信息</p>
<ol>
<li>文件名</li>
<li>文件物理位置</li>
<li>存取信息: 创建时间, 读写访问时间</li>
</ol>
<p>文件的<code>元数据</code>在<code>目录项</code>和<code>inode</code>中, incode缺少文件名</p>
<p>目录结构包括: <code>单级目录</code>, <code>两级目录</code>, <code>层次结构</code></p>
<p>文件共享包括两个方面<code>用户共享</code>和<code>实体共享</code></p>
<p>用户共享会遇到<code>访问权限</code>和<code>并发控制</code>的问题</p>
<p>实体共享在Unix系统上通过<code>链接</code>实现.</p>
<ul>
<li>硬链接: 多个文件名链接到同一个<code>索引结点</code></li>
<li>软链接: 建立一个独立于源文件的<code>符号链接</code>文件</li>
</ul>
<h3 id="区分重要算法">区分重要算法</h3>
<p>进程调度</p>
<ul>
<li>抢占算法的抢占时机</li>
<li>FCFS/ SJF/ SRT/ HRRN/ RR</li>
</ul>
<p>页面替换</p>
<ul>
<li>OPT/ FIFO/ LRU/ CLOCK</li>
</ul>
<p>磁盘调度</p>
<ul>
<li>FCFS/ SSTF</li>
<li>SCAN/ LOOK/ CSCAN/ CLOOK</li>
</ul>
<p>内存分配(动态分区)</p>
<ul>
<li>空闲分区组织方式</li>
<li>First Fit/ Next First Fit/ Best Fit/ Worst Fit</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>

  </article>

  <!-- prev and next -->
  <div class="flex justify-between mt-4 pt-4
    border-t border-[var(--c-sep)] text-sm
    gap-2 text-[var(--c-50)]
  ">
    <div>
      
        <a href="/2024/04/11/course-note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%A2%84%E4%B9%A0/"
          class="
            transition-all
            flex justify-center
            hover:-translate-x-1
            hover:text-[var(--c-80)]
          ">
          <iconify-icon width="20" icon="mingcute:left-fill" data-inline="false">
          </iconify-icon>
          2022-2023春季学期计算机组成原理期末预习笔记
        </a>
      
    </div>
    <div>
      
        <a href="/2024/04/11/Article/2024/%E6%88%91%E7%88%B1%E4%BD%A0/"
          class="
            flex 
            justify-center
            hover:translate-x-1 
            transition-transform
            hover:text-[var(--c-100)]
          "
        >
          我爱你
          <iconify-icon width="20" icon="mingcute:right-fill" data-inline="false"></iconify-icon>
        </a>
      
    </div>
  </div>

  <!-- comment -->
  <div class="article-comments mt-12">
    
  <script src="https://giscus.app/client.js"
  data-repo="421zuoduan/blog-giscus-discussion"
  data-repo-id="R_kgDONKEKag"
  data-category="Announcements"
  data-category-id="DIC_kwDONKEKas4Cj9R8"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="1"
  data-input-position="top"
  data-theme="preferred_color_scheme"
  data-lang="zh-CN"
  data-loading="lazy"
  crossorigin="anonymous"
  async>
</script>
<script>
  window.onload = function () {
    console.log("giscus loaded");
    const isDark = document.documentElement.classList.contains("dark");
    const giscusFrame = document.querySelector("iframe.giscus-frame");
    giscusFrame.contentWindow.postMessage(
      {
        giscus: {
          setConfig: {
            theme: isDark ? "dark" : "light",
          },
        },
      },
      "https://giscus.app"
    );
  };
</script>


  </div>
</section>
<!-- js inspect -->

<script src="/lib/clipboard.min.js"></script>


<script async src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  $(document).ready(() => {
    const maraidConfig = {
      theme: "default",
      logLevel: 3,
      flowchart: { curve: "linear" },
      gantt: { axisFormat: "%m/%d/%Y" },
      sequence: { actorMargin: 50 },
    };
    mermaid.initialize(maraidConfig);
  });
</script>



<script src="/lib/fancybox/fancybox.umd.min.js"></script>

<script>
  $(document).ready(() => {
    $('.post-content').each(function(i){
      $(this).find('img').each(function(){
        if ($(this).parent().hasClass('fancybox') || $(this).parent().is('a')) return;
        var alt = this.alt;
        var title = this.title;
        if (alt) $(this).after('<span class="fancybox-alt">' + alt + '</span>');
        if (title) $(this).after('<span class="fancybox-title">' + title + '</span>');
        $(this).wrap('<a class="fancybox-img" href="' + this.src + '" data-fancybox=\"gallery\" data-caption="' + alt + '"></a>')
      });
      $(this).find('.fancybox').each(function(){
        $(this).attr('rel', 'article' + i);
      });
    });

    Fancybox.bind('[data-fancybox="gallery"]', {
        // options
    })
  })
</script>

<!-- tocbot begin -->

<script src="/lib/tocbot/tocbot.min.js"></script>

<script>
  $(document).ready(() => {
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '.post-toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '.post-content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h1, h2, h3',
        // For headings inside relative or absolute positioned containers within content.
        hasInnerContainers: true,
    });
  })
</script>
<!-- tocbot end -->

  </main>
  <footer class="flex flex-col mt-18 mb-12 items-center
  text-[var(--c-50)] text-sm">
  <div class="flex flex-row items-center my-12">
    
    
        
        
            
            
        
        <a class="
            hover:text-[var(--c-theme)]
            hover:bg-[var(--c-20)]
            rounded-lg
            p-2
            my-1
            flex flex-row items-center
            group" title="Github" target="_blank" rel="noopener" href="https://www.github.com/421zuoduan">
            <iconify-icon width="28" icon="mingcute:github-fill"></iconify-icon>
        </a>
    
        
        
            
            
        
        <a class="
            hover:text-[var(--c-theme)]
            hover:bg-[var(--c-20)]
            rounded-lg
            p-2
            my-1
            flex flex-row items-center
            group" title="ZhiHu" target="_blank" rel="noopener" href="https://www.zhihu.com/people/ren-jian-lan-xue">
            <iconify-icon width="28" icon="ri:zhihu-line"></iconify-icon>
        </a>
    

  </div>
  <!-- busuanzi -->
  <div class="mb-6">
    
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Busuanzi Analytics -->
<div class="flex flex-col items-center mb-2">
  <div class="flex flex-row items-center">
    <iconify-icon width="16" icon="ic:round-person" width="18"></iconify-icon>
    <span class="mr-1">访客 Visitors: </span>
    <span id="busuanzi_value_site_uv"></span>
  </div>
  <div class="flex flex-row items-center">
    <iconify-icon width="16" icon="carbon:view-filled" width="18"></iconify-icon>
    <span class="mx-1">浏览量 Page Views:</span>
    <span id="busuanzi_value_site_pv"></span>
  </div>
</div>
<!-- End Busuanzi Analytics -->


  </div>
  <!-- copyright -->
  <div class="flex flex-row items-center gap-2">
    <a class="hover:underline"
      target="_blank"
      href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
    >
      CC BY-NC-SA 4.0
    </a>
    <span>© 2022-2024</span>
    <a class="hover:underline"
    href="https://github.com/chen-yingfa" 
    target="_blank" 
    rel="noopener noreferrer">陈英发</a>
  </div>
  <!-- powered by -->
  <div class="flex items-center gap-1">
    <span>Powered by</span>
    <a class="hover:underline" 
    href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>
    <span>&</span>
    <a href="https://github.com/chen-yingfa/hexo-theme-fengye" 
    class="hover:underline"
    target="_blank"
      rel="noopener noreferrer"
      >
      枫叶 Fengye
    </a>
  </div>

</footer>

  <div class="
    back-to-top
    fixed right-6
    z-1024
    -bottom-20
    rounded-lg
    font-bold
    py-1 px-2
    text-[var(--c-80)]
    bg-[var(--c-20)]
    cursor-pointer
    text-center
    drop-shadow-md
  ">
    <span class="flex justify-center items-center text-sm">
      <span id="scrollpercent"><span>0</span> %</span>
      <iconify-icon width="18" icon="mingcute:arrow-to-up-fill" id="go-top"></iconify-icon>
    </span>
  </div>
  
<script src="/js/main.js"></script>


  <div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden" id="maple"></div>
</body>

</html>
